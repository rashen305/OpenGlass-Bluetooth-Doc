{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"Firmware/","title":"Firmware","text":"<p>BLEUUID Constructor BLEServerCallbacks BLECharacteristicCallbacks getLength() getData() BLEDevice::init BLEDevice::createServer() setCallbacks server-&gt;createService server-&gt;createCharacteristic BLE2902() setNotifications() addDescriptor() BLECharacteristic-&gt;setValue() BLEservice-&gt;start() BLEAdvertising::BLEAdvertising() BLEDevice::getAdvertising addServiceUUID getUUID() setScanResponse() setMin/MaxPreffered() BLEDevice::startAdvertising() BLECharacteristic-&gt;notify()</p> firmware.ino<pre><code>#define CAMERA_MODEL_XIAO_ESP32S3\n#include &lt;Arduino.h&gt;\n#include &lt;BLE2902.h&gt;\n#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEScan.h&gt;\n#include &lt;BLEAdvertisedDevice.h&gt;\n#include \"esp_camera.h\"\n#include \"camera_pins.h\"\n\n// ---------------------------------------------------------------------------------\n// BLE\n// ---------------------------------------------------------------------------------\n\n// Device Information Service\n#define DEVICE_INFORMATION_SERVICE_UUID (uint16_t)0x180A\n#define MANUFACTURER_NAME_STRING_CHAR_UUID (uint16_t)0x2A29\n#define MODEL_NUMBER_STRING_CHAR_UUID (uint16_t)0x2A24\n#define FIRMWARE_REVISION_STRING_CHAR_UUID (uint16_t)0x2A26\n#define HARDWARE_REVISION_STRING_CHAR_UUID (uint16_t)0x2A27\n\n// Main Friend Service - linked\nstatic BLEUUID serviceUUID(\"19B10000-E8F2-537E-4F6C-D104768A1214\");\nstatic BLEUUID photoDataUUID(\"19B10005-E8F2-537E-4F6C-D104768A1214\");\nstatic BLEUUID photoControlUUID(\"19B10006-E8F2-537E-4F6C-D104768A1214\");\n\n// Characteristics\nBLECharacteristic *photoDataCharacteristic;\nBLECharacteristic *photoControlCharacteristic;\n\n// State\nbool connected = false;\nbool isCapturingPhotos = false;\nint captureInterval = 0;         // Interval in ms\nunsigned long lastCaptureTime = 0;\n\nsize_t sent_photo_bytes = 0;\nsize_t sent_photo_frames = 0;\nbool photoDataUploading = false;\n\n// -------------------------------------------------------------------------\n// Camera Frame\n// -------------------------------------------------------------------------\ncamera_fb_t *fb = nullptr;\n\n// Forward declaration\nvoid handlePhotoControl(int8_t controlValue);\n\nclass ServerHandler : public BLEServerCallbacks { //linked\n  void onConnect(BLEServer *server) override {\n    connected = true;\n    Serial.println(\"&gt;&gt;&gt; BLE Client connected.\");\n  }\n  void onDisconnect(BLEServer *server) override {\n    connected = false;\n    Serial.println(\"&lt;&lt;&lt; BLE Client disconnected. Restarting advertising.\");\n    BLEDevice::startAdvertising();\n  }\n};\n\nclass PhotoControlCallback : public BLECharacteristicCallbacks { //linked\n  void onWrite(BLECharacteristic *characteristic) override {\n    if (characteristic-&gt;getLength() == 1) { //linked\n      int8_t received = characteristic-&gt;getData()[0]; //linked\n      Serial.print(\"PhotoControl received: \");\n      Serial.println(received);\n      handlePhotoControl(received);\n    }\n  }\n};\n\n// -------------------------------------------------------------------------\n// configure_ble()\n// -------------------------------------------------------------------------\nvoid configure_ble() {\n  Serial.println(\"Initializing BLE...\");\n  BLEDevice::init(\"OpenGlass\"); //linked\n  BLEServer *server = BLEDevice::createServer(); //linked\n  server-&gt;setCallbacks(new ServerHandler()); //linked\n\n  // Main service\n  BLEService *service = server-&gt;createService(serviceUUID); //linked\n\n  // Photo Data characteristic\n  photoDataCharacteristic = service-&gt;createCharacteristic(\n      photoDataUUID,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);//linked\n  BLE2902 *ccc = new BLE2902(); //linked\n  ccc-&gt;setNotifications(true); //linked\n  photoDataCharacteristic-&gt;addDescriptor(ccc); //linked\n\n  // Photo Control characteristic\n  photoControlCharacteristic = service-&gt;createCharacteristic(\n      photoControlUUID,\n      BLECharacteristic::PROPERTY_WRITE);\n  photoControlCharacteristic-&gt;setCallbacks(new PhotoControlCallback());\n  uint8_t controlValue = 0;\n  photoControlCharacteristic-&gt;setValue(&amp;controlValue, 1); //linked\n\n  // Device Information Service\n  BLEService *deviceInfoService = server-&gt;createService(DEVICE_INFORMATION_SERVICE_UUID); //linked\n  BLECharacteristic *manufacturerNameCharacteristic =\n      deviceInfoService-&gt;createCharacteristic(MANUFACTURER_NAME_STRING_CHAR_UUID,\n                                              BLECharacteristic::PROPERTY_READ);\n  BLECharacteristic *modelNumberCharacteristic =\n      deviceInfoService-&gt;createCharacteristic(MODEL_NUMBER_STRING_CHAR_UUID,\n                                              BLECharacteristic::PROPERTY_READ);\n  BLECharacteristic *firmwareRevisionCharacteristic =\n      deviceInfoService-&gt;createCharacteristic(FIRMWARE_REVISION_STRING_CHAR_UUID,\n                                              BLECharacteristic::PROPERTY_READ);\n  BLECharacteristic *hardwareRevisionCharacteristic =\n      deviceInfoService-&gt;createCharacteristic(HARDWARE_REVISION_STRING_CHAR_UUID,\n                                              BLECharacteristic::PROPERTY_READ);\n\n  manufacturerNameCharacteristic-&gt;setValue(\"Based Hardware\"); //linked\n  modelNumberCharacteristic-&gt;setValue(\"OpenGlass\");\n  firmwareRevisionCharacteristic-&gt;setValue(\"1.0.1\");\n  hardwareRevisionCharacteristic-&gt;setValue(\"Seeed Xiao ESP32S3 Sense\");\n\n  // Start services\n  service-&gt;start(); //linked\n  deviceInfoService-&gt;start();\n\n  // Start advertising\n  BLEAdvertising *advertising = BLEDevice::getAdvertising(); //linked\n  advertising-&gt;addServiceUUID(deviceInfoService-&gt;getUUID()); //linked\n  advertising-&gt;addServiceUUID(service-&gt;getUUID());\n  advertising-&gt;setScanResponse(true);//linked\n  advertising-&gt;setMinPreferred(0x06);//linked\n  advertising-&gt;setMaxPreferred(0x12);\n  BLEDevice::startAdvertising();//linked\n\n  Serial.println(\"BLE initialized and advertising started.\");\n}\n\n// -------------------------------------------------------------------------\n// Camera\n// -------------------------------------------------------------------------\nbool take_photo() {\n  // Release previous buffer\n  if (fb) {\n    Serial.println(\"Releasing previous camera buffer...\");\n    esp_camera_fb_return(fb); //esp_camera.h\n    fb = nullptr;\n  }\n\n  Serial.println(\"Capturing photo...\");\n  fb = esp_camera_fb_get();\n  if (!fb) {\n    Serial.println(\"Failed to get camera frame buffer!\");\n    return false;\n  }\n  Serial.print(\"Photo captured: \");\n  Serial.print(fb-&gt;len);\n  Serial.println(\" bytes.\");\n  return true;\n}\n\nvoid handlePhotoControl(int8_t controlValue) {\n  if (controlValue == -1) {\n    Serial.println(\"Received command: Single photo.\");\n    isCapturingPhotos = true;\n    captureInterval = 0;\n  }\n  else if (controlValue == 0) {\n    Serial.println(\"Received command: Stop photo capture.\");\n    isCapturingPhotos = false;\n    captureInterval = 0;\n  }\n  else if (controlValue &gt;= 5 &amp;&amp; controlValue &lt;= 300) {\n    Serial.print(\"Received command: Start interval capture with parameter \");\n    Serial.println(controlValue);\n\n    // ---------------------------\n    // Hard-code 30s interval here\n    // ---------------------------\n    captureInterval = 30000;  // 30 seconds\n\n    isCapturingPhotos = true;\n    lastCaptureTime = millis() - captureInterval;\n  }\n}\n\n// -------------------------------------------------------------------------\n// configure_camera()\n// -------------------------------------------------------------------------\nvoid configure_camera() {\n  Serial.println(\"Initializing camera...\");\n  camera_config_t config;\n  config.ledc_channel = LEDC_CHANNEL_0;\n  config.ledc_timer   = LEDC_TIMER_0;\n  config.pin_d0       = Y2_GPIO_NUM;\n  config.pin_d1       = Y3_GPIO_NUM;\n  config.pin_d2       = Y4_GPIO_NUM;\n  config.pin_d3       = Y5_GPIO_NUM;\n  config.pin_d4       = Y6_GPIO_NUM;\n  config.pin_d5       = Y7_GPIO_NUM;\n  config.pin_d6       = Y8_GPIO_NUM;\n  config.pin_d7       = Y9_GPIO_NUM;\n  config.pin_xclk     = XCLK_GPIO_NUM;\n  config.pin_pclk     = PCLK_GPIO_NUM;\n  config.pin_vsync    = VSYNC_GPIO_NUM;\n  config.pin_href     = HREF_GPIO_NUM;\n  config.pin_sscb_sda = SIOD_GPIO_NUM;\n  config.pin_sscb_scl = SIOC_GPIO_NUM;\n  config.pin_pwdn     = PWDN_GPIO_NUM;\n  config.pin_reset    = RESET_GPIO_NUM;\n  config.xclk_freq_hz = 20000000;\n\n  // Example: 800x600, JPEG\n  config.frame_size   = FRAMESIZE_SVGA;\n  config.pixel_format = PIXFORMAT_JPEG;\n  config.fb_count     = 1;\n  config.jpeg_quality = 10;\n  config.fb_location  = CAMERA_FB_IN_PSRAM;\n  config.grab_mode    = CAMERA_GRAB_LATEST;\n\n  esp_err_t err = esp_camera_init(&amp;config);\n  if (err != ESP_OK) {\n    Serial.printf(\"Camera init failed with error 0x%x\\n\", err);\n  }\n  else {\n    Serial.println(\"Camera initialized successfully.\");\n  }\n}\n\n// -------------------------------------------------------------------------\n// Setup &amp; Loop\n// -------------------------------------------------------------------------\n\n// A small buffer for sending photo chunks over BLE\nstatic uint8_t *s_compressed_frame_2 = nullptr;\n\nvoid setup() {\n  Serial.begin(921600);\n  Serial.println(\"Setup started...\");\n\n  configure_ble();\n  configure_camera();\n\n  // Allocate buffer for photo chunks (200 bytes + 2 for frame index)\n  s_compressed_frame_2 = (uint8_t *)ps_calloc(202, sizeof(uint8_t));\n  if (!s_compressed_frame_2) {\n    Serial.println(\"Failed to allocate chunk buffer!\");\n  } else {\n    Serial.println(\"Chunk buffer allocated successfully.\");\n  }\n\n  // Force a 30s default capture interval\n  isCapturingPhotos = true;\n  captureInterval = 30000; // 30 seconds\n  lastCaptureTime = millis() - captureInterval;\n  Serial.println(\"Default capture interval set to 30 seconds.\");\n}\n\nvoid loop() {\n  unsigned long now = millis();\n\n  // Check if it's time to capture a photo\n  if (isCapturingPhotos &amp;&amp; !photoDataUploading &amp;&amp; connected) {\n    if ((captureInterval == 0) || (now - lastCaptureTime &gt;= (unsigned long)captureInterval)) {\n      if (captureInterval == 0) {\n        // Single shot if interval=0\n        isCapturingPhotos = false;\n      }\n      Serial.println(\"Interval reached. Capturing photo...\");\n      if (take_photo()) {\n        Serial.println(\"Photo capture successful. Starting upload...\");\n        photoDataUploading = true;\n        sent_photo_bytes = 0;\n        sent_photo_frames = 0;\n        lastCaptureTime = now;\n      }\n    }\n  }\n\n  // If uploading, send chunks over BLE\n  if (photoDataUploading &amp;&amp; fb) {\n    size_t remaining = fb-&gt;len - sent_photo_bytes;\n    if (remaining &gt; 0) {\n      // Prepare chunk\n      s_compressed_frame_2[0] = (uint8_t)(sent_photo_frames &amp; 0xFF);\n      s_compressed_frame_2[1] = (uint8_t)((sent_photo_frames &gt;&gt; 8) &amp; 0xFF);\n      size_t bytes_to_copy = (remaining &gt; 200) ? 200 : remaining;\n      memcpy(&amp;s_compressed_frame_2[2], &amp;fb-&gt;buf[sent_photo_bytes], bytes_to_copy);\n\n      photoDataCharacteristic-&gt;setValue(s_compressed_frame_2, bytes_to_copy + 2);\n      photoDataCharacteristic-&gt;notify(); //linked\n\n      sent_photo_bytes += bytes_to_copy;\n      sent_photo_frames++;\n\n      Serial.print(\"Uploading chunk \");\n      Serial.print(sent_photo_frames);\n      Serial.print(\" (\");\n      Serial.print(bytes_to_copy);\n      Serial.print(\" bytes), \");\n      Serial.print(remaining - bytes_to_copy);\n      Serial.println(\" bytes remaining.\");\n    }\n    else {\n      // End of photo marker\n      s_compressed_frame_2[0] = 0xFF;\n      s_compressed_frame_2[1] = 0xFF;\n      photoDataCharacteristic-&gt;setValue(s_compressed_frame_2, 2);\n      photoDataCharacteristic-&gt;notify();\n      Serial.println(\"Photo upload complete.\");\n\n      photoDataUploading = false;\n      // Free camera buffer\n      esp_camera_fb_return(fb);\n      fb = nullptr;\n      Serial.println(\"Camera frame buffer freed.\");\n    }\n  }\n\n  delay(20);\n}\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/","title":"Arduino BLE Libraries","text":""},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleuuid-constructor","title":"BLEUUID Constructor","text":"<p>esp_bt_uuid_t <pre><code>BLEUUID::BLEUUID(String value) {\n  //Serial.printf(\"BLEUUID constructor from String=\\\"%s\\\"\\n\", value.c_str());\n  m_valueSet = true;\n  if (value.length() == 4) {\n    m_uuid.len = ESP_UUID_LEN_16; //defined as linked m_uuid;\n    m_uuid.uuid.uuid16 = 0;\n    for (int i = 0; i &lt; value.length();) {\n      uint8_t MSB = value.c_str()[i];\n      uint8_t LSB = value.c_str()[i + 1];\n\n      if (MSB &gt; '9') {\n        MSB -= 7;\n      }\n      if (LSB &gt; '9') {\n        LSB -= 7;\n      }\n      m_uuid.uuid.uuid16 += (((MSB &amp; 0x0F) &lt;&lt; 4) | (LSB &amp; 0x0F)) &lt;&lt; (2 - i) * 4;\n      i += 2;\n    }\n  } else if (value.length() == 8) {\n    m_uuid.len = ESP_UUID_LEN_32;\n    m_uuid.uuid.uuid32 = 0;\n    for (int i = 0; i &lt; value.length();) {\n      uint8_t MSB = value.c_str()[i];\n      uint8_t LSB = value.c_str()[i + 1];\n\n      if (MSB &gt; '9') {\n        MSB -= 7;\n      }\n      if (LSB &gt; '9') {\n        LSB -= 7;\n      }\n      m_uuid.uuid.uuid32 += (((MSB &amp; 0x0F) &lt;&lt; 4) | (LSB &amp; 0x0F)) &lt;&lt; (6 - i) * 4;\n      i += 2;\n    }\n  } else if (value.length()\n             == 16) {  // How we can have 16 byte length string representing 128 bit uuid??? needs to be investigated (lack of time) - maybe raw data encoded as String (128b==16B)?\n    m_uuid.len = ESP_UUID_LEN_128;\n    memrcpy(m_uuid.uuid.uuid128, (uint8_t *)value.c_str(), 16);\n  } else if (value.length() == 36) {\n    //log_d(\"36 characters:\");\n    // If the length of the string is 36 bytes then we will assume it is a long hex string in\n    // UUID format.\n    m_uuid.len = ESP_UUID_LEN_128;\n    int n = 0;\n    for (int i = 0; i &lt; value.length();) {\n      if (value.c_str()[i] == '-') {\n        i++;\n      }\n      uint8_t MSB = value.c_str()[i];\n      uint8_t LSB = value.c_str()[i + 1];\n\n      if (MSB &gt; '9') {\n        MSB -= 7;\n      }\n      if (LSB &gt; '9') {\n        LSB -= 7;\n      }\n      m_uuid.uuid.uuid128[15 - n++] = ((MSB &amp; 0x0F) &lt;&lt; 4) | (LSB &amp; 0x0F);\n      i += 2;\n    }\n  } else {\n    log_e(\"ERROR: UUID value not 2, 4, 16 or 36 bytes\");\n    m_valueSet = false;\n  }\n}  //BLEUUID(String)\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservercallbacks","title":"BLEServerCallbacks","text":"<pre><code>void BLEServerCallbacks::onConnect(BLEServer *pServer) {\n  log_d(\"BLEServerCallbacks\", \"&gt;&gt; onConnect(): Default\");\n  log_d(\"BLEServerCallbacks\", \"Device: %s\", BLEDevice::toString().c_str());\n  log_d(\"BLEServerCallbacks\", \"&lt;&lt; onConnect()\");\n}  // onConnect\n\nvoid BLEServerCallbacks::onDisconnect(BLEServer *pServer) {\n  log_d(\"BLEServerCallbacks\", \"&gt;&gt; onDisconnect(): Default\");\n  log_d(\"BLEServerCallbacks\", \"Device: %s\", BLEDevice::toString().c_str());\n  log_d(\"BLEServerCallbacks\", \"&lt;&lt; onDisconnect()\");\n}  // onDisconnect\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristiccallbacks","title":"BLECharacteristicCallbacks","text":"<pre><code>void BLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic) {\n  log_d(\"&gt;&gt; onWrite: default\");\n  log_d(\"&lt;&lt; onWrite\");\n}  // onWrite\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#characteristic-getlength","title":"characteristic-&gt;getLength()","text":"<p>BLEValue <pre><code>size_t BLECharacteristic::getLength() {\n  return m_value.getLength(); //linked m_value; private variable in the class\n}  // getLength\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#characteristic-getdata","title":"characteristic-&gt;getData()","text":"<p>BLEValue <pre><code>uint8_t *BLECharacteristic::getData() {\n  return m_value.getData(); //linked m_value; private variable in the class\n}  // getData\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blevalue","title":"BLEValue","text":"<pre><code>BLEValue::BLEValue() {\n  m_accumulation = \"\"; //String m_accumulation;\n  m_value = \"\"; //String m_value;\n  m_readOffset = 0; //uint16_t m_readOffset;\n}  // BLEValue\n\nsize_t BLEValue::getLength() {\n  return m_value.length();\n}  // getLength\n\nuint8_t *BLEValue::getData() {\n  return (uint8_t *)m_value.c_str();\n}\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledeviceinit","title":"BLEDevice::init","text":"<p>btStart() esp_err_t nvs_flash_init esp_bt_controller_mem_release esp_bt_mode_t esp_bt_controller_config_t BT_CONTROLLER_INIT_CONFIG_DEFAULT esp_bt_controller_init esp_bt_controller_enable esp_bluedroid_status_t esp_bluedroid_get_status esp_bluedroid_init esp_bluedroid_enable esp_ble_gap_register_callback esp_ble_gattc_register_callback esp_ble_gap_set_device_name esp_ble_gap_set_security_param <pre><code>/* STATIC */ void BLEDevice::init(String deviceName) {\n  if (!initialized) {\n    initialized = true;  // Set the initialization flag to ensure we are only initialized once.\n\n    esp_err_t errRc = ESP_OK;\n#ifdef ARDUINO_ARCH_ESP32\n    if (!btStart()) { //linked\n      errRc = ESP_FAIL; //linked errRc; #define ESP_FAIL        -1\n      return;\n    }\n#else\n    errRc = ::nvs_flash_init(); //linked\n    if (errRc != ESP_OK) { //#define ESP_OK 0\n      log_e(\"nvs_flash_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n\n#ifndef CONFIG_BT_CLASSIC_ENABLED\n    esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT); // linked and (linked mode);\n#endif\n    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT(); //linked and linked\n    errRc = esp_bt_controller_init(&amp;bt_cfg); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_bt_controller_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n\n#ifndef CONFIG_BT_CLASSIC_ENABLED\n    errRc = esp_bt_controller_enable(ESP_BT_MODE_BLE); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n#else\n    errRc = esp_bt_controller_enable(ESP_BT_MODE_BTDM);\n    if (errRc != ESP_OK) {\n      log_e(\"esp_bt_controller_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n#endif\n#endif\n\n    esp_bluedroid_status_t bt_state = esp_bluedroid_get_status(); //linked and linked\n    if (bt_state == ESP_BLUEDROID_STATUS_UNINITIALIZED) {\n      errRc = esp_bluedroid_init(); //linked\n      if (errRc != ESP_OK) {\n        log_e(\"esp_bluedroid_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n        return;\n      }\n    }\n\n    if (bt_state != ESP_BLUEDROID_STATUS_ENABLED) {\n      errRc = esp_bluedroid_enable(); //linked\n      if (errRc != ESP_OK) {\n        log_e(\"esp_bluedroid_enable: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n        return;\n      }\n    }\n\n    errRc = esp_ble_gap_register_callback(BLEDevice::gapEventHandler); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_ble_gap_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n\n#ifdef CONFIG_GATTC_ENABLE  // Check that BLE client is configured in make menuconfig\n    errRc = esp_ble_gattc_register_callback(BLEDevice::gattClientEventHandler); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_ble_gattc_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n#endif  // CONFIG_GATTC_ENABLE\n\n#ifdef CONFIG_GATTS_ENABLE  // Check that BLE server is configured in make menuconfig\n    errRc = esp_ble_gatts_register_callback(BLEDevice::gattServerEventHandler);\n    if (errRc != ESP_OK) {\n      log_e(\"esp_ble_gatts_register_callback: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n#endif  // CONFIG_GATTS_ENABLE\n\n    errRc = ::esp_ble_gap_set_device_name(deviceName.c_str()); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_ble_gap_set_device_name: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    };\n\n#ifdef CONFIG_BLE_SMP_ENABLE  // Check that BLE SMP (security) is configured in make menuconfig\n    esp_ble_io_cap_t iocap = ESP_IO_CAP_NONE;\n    errRc = ::esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &amp;iocap, sizeof(uint8_t)); //linked\n    if (errRc != ESP_OK) {\n      log_e(\"esp_ble_gap_set_security_param: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    };\n#endif  // CONFIG_BLE_SMP_ENABLE\n  }\n  vTaskDelay(200 / portTICK_PERIOD_MS);  // Delay for 200 msecs as a workaround to an apparent Arduino environment issue.\n}  // init\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#btstart","title":"btStart()","text":"<p>btStartMode() <pre><code>bool btStart() {\n  return btStartMode(BT_MODE); //linked\n}\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#btstartmode","title":"btStartMode()","text":"<p>esp_bt_controller_get_status esp_err_to_name <pre><code>bool btStartMode(bt_mode mode) {\n  esp_bt_mode_t esp_bt_mode;\n  esp_bt_controller_config_t cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();\n#if CONFIG_IDF_TARGET_ESP32\n  switch (mode) {\n    case BT_MODE_BLE:        esp_bt_mode = ESP_BT_MODE_BLE; break;\n    case BT_MODE_CLASSIC_BT: esp_bt_mode = ESP_BT_MODE_CLASSIC_BT; break;\n    case BT_MODE_BTDM:       esp_bt_mode = ESP_BT_MODE_BTDM; break;\n    default:                 esp_bt_mode = BT_MODE; break;\n  }\n  // esp_bt_controller_enable(MODE) This mode must be equal as the mode in \"cfg\" of esp_bt_controller_init().\n  cfg.mode = esp_bt_mode;\n  if (cfg.mode == ESP_BT_MODE_CLASSIC_BT) {\n    esp_bt_controller_mem_release(ESP_BT_MODE_BLE);\n  }\n#else\n  // other esp variants dont support BT-classic / DM.\n  esp_bt_mode = BT_MODE;\n#endif\n\n  if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_ENABLED) { //linked\n    return true;\n  }\n  esp_err_t ret;\n  if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_IDLE) {\n    if ((ret = esp_bt_controller_init(&amp;cfg)) != ESP_OK) {\n      log_e(\"initialize controller failed: %s\", esp_err_to_name(ret));\n      return false;\n    }\n    while (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_IDLE) {}\n  }\n  if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_INITED) {\n    if ((ret = esp_bt_controller_enable(esp_bt_mode)) != ESP_OK) {\n      log_e(\"BT Enable mode=%d failed %s\", BT_MODE, esp_err_to_name(ret)); //linked\n      return false;\n    }\n  }\n  if (esp_bt_controller_get_status() == ESP_BT_CONTROLLER_STATUS_ENABLED) {\n    return true;\n  }\n  log_e(\"BT Start failed\");\n  return false;\n}\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledevicecreateserver","title":"BLEDevice::createServer()","text":"<p>BLEServer::BLEServer() BLEServer::createApp <pre><code>/**\n * @brief Create a new instance of a server.\n * @return A new instance of the server.\n */\n/* STATIC */ BLEServer* BLEDevice::createServer() {\n    ESP_LOGD(LOG_TAG, \"&gt;&gt; createServer\");\n#ifndef CONFIG_GATTS_ENABLE  // Check that BLE GATTS is enabled in make menuconfig\n    ESP_LOGE(LOG_TAG, \"BLE GATTS is not enabled - CONFIG_GATTS_ENABLE not defined\");\n    abort();\n#endif // CONFIG_GATTS_ENABLE\n    m_pServer = new BLEServer(); //linked\n    m_pServer-&gt;createApp(m_appId++); //linked\n    ESP_LOGD(LOG_TAG, \"&lt;&lt; createServer\");\n    return m_pServer;\n} // createServer\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleserverbleserver","title":"BLEServer::BLEServer()","text":"<pre><code>BLEServer::BLEServer() {\n  m_appId = ESP_GATT_IF_NONE;\n  m_gatts_if = ESP_GATT_IF_NONE;\n  m_connectedCount = 0;\n  m_connId = ESP_GATT_IF_NONE;\n  m_pServerCallbacks = nullptr;\n}  // BLEServer\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservercreateapp","title":"BLEServer::createApp","text":"<p>BLEServer::registerApp <pre><code>void BLEServer::createApp(uint16_t appId) {\n  m_appId = appId;\n  registerApp(appId); //linked\n}  // createApp\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleserverregisterapp","title":"BLEServer::registerApp","text":"<p>m_semaphoreRegisterAppEvt esp_ble_gatts_app_register <pre><code>void BLEServer::registerApp(uint16_t m_appId) {\n  log_v(\"&gt;&gt; registerApp - %d\", m_appId);\n  m_semaphoreRegisterAppEvt.take(\"registerApp\");  // Take the mutex, will be released by ESP_GATTS_REG_EVT event.\n  //linked\n  ::esp_ble_gatts_app_register(m_appId); //linked\n  m_semaphoreRegisterAppEvt.wait(\"registerApp\");\n  log_v(\"&lt;&lt; registerApp\");\n}  // registerApp\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#m_semaphoreregisterappevt","title":"m_semaphoreRegisterAppEvt","text":"<pre><code>FreeRTOS::Semaphore m_semaphoreRegisterAppEvt = FreeRTOS::Semaphore(\"RegisterAppEvt\");\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#setcallbacks","title":"setCallbacks","text":"<pre><code>void BLEServer::setCallbacks(BLEServerCallbacks *pCallbacks) {\n  m_pServerCallbacks = pCallbacks;\n}  // setCallbacks\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#server-createservice","title":"server-&gt;createService","text":"<p>BLEServer::createService <pre><code>BLEService *BLEServer::createService(const char *uuid) {\n  return createService(BLEUUID(uuid)); //linked\n}\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservercreateservice","title":"BLEServer::createService","text":"<p>BLEServiceMap BLEServiceMap::getByUUID BLEService::BLEService BLEServiceMap::setByUUID executeCreate <pre><code>BLEService *BLEServer::createService(BLEUUID uuid, uint32_t numHandles, uint8_t inst_id) {\n  log_v(\"&gt;&gt; createService - %s\", uuid.toString().c_str());\n  m_semaphoreCreateEvt.take(\"createService\");\n\n  // Check that a service with the supplied UUID does not already exist.\n  if (m_serviceMap.getByUUID(uuid) != nullptr) { //linked and linked\n    log_w(\"&lt;&lt; Attempt to create a new service with uuid %s but a service with that UUID already exists.\", uuid.toString().c_str());\n  }\n\n  BLEService *pService = new BLEService(uuid, numHandles); //linked\n  pService-&gt;m_instId = inst_id;\n  m_serviceMap.setByUUID(uuid, pService);  // Save a reference to this service being on this server. linked\n  pService-&gt;executeCreate(this);           // Perform the API calls to actually create the service. linked\n\n  m_semaphoreCreateEvt.wait(\"createService\");\n\n  log_v(\"&lt;&lt; createService\");\n  return pService;\n}  // createService\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservicebleservice","title":"BLEService::BLEService","text":"<pre><code>BLEService::BLEService(const char *uuid, uint16_t numHandles) : BLEService(BLEUUID(uuid), numHandles) {}\n\n/**\n * @brief Construct an instance of the BLEService\n * @param [in] uuid The UUID of the service.\n * @param [in] numHandles The maximum number of handles associated with the service.\n */\nBLEService::BLEService(BLEUUID uuid, uint16_t numHandles) {\n  m_uuid = uuid;\n  m_handle = NULL_HANDLE;\n  m_pServer = nullptr;\n  //m_serializeMutex.setName(\"BLEService\");\n  m_lastCreatedCharacteristic = nullptr;\n  m_numHandles = numHandles;\n}  // BLEService\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservicemap","title":"BLEServiceMap","text":"<pre><code>class BLEServiceMap {\npublic:\n  BLEService *getByHandle(uint16_t handle);\n  BLEService *getByUUID(const char *uuid);\n  BLEService *getByUUID(BLEUUID uuid, uint8_t inst_id = 0);\n  void handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param);\n  void setByHandle(uint16_t handle, BLEService *service);\n  void setByUUID(const char *uuid, BLEService *service);\n  void setByUUID(BLEUUID uuid, BLEService *service);\n  String toString();\n  BLEService *getFirst();\n  BLEService *getNext();\n  void removeService(BLEService *service);\n  int getRegisteredServiceCount();\n\nprivate:\n  std::map&lt;uint16_t, BLEService *&gt; m_handleMap;\n  std::map&lt;BLEService *, String&gt; m_uuidMap;\n  std::map&lt;BLEService *, String&gt;::iterator m_iterator;\n};\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservicemapgetbyuuid","title":"BLEServiceMap::getByUUID","text":"<pre><code>BLEService *BLEServiceMap::getByUUID(const char *uuid) {\n  return getByUUID(BLEUUID(uuid));\n}\n\n/**\n * @brief Return the service by UUID.\n * @param [in] UUID The UUID to look up the service.\n * @return The characteristic.\n */\nBLEService *BLEServiceMap::getByUUID(BLEUUID uuid, uint8_t inst_id) {\n  for (auto &amp;myPair : m_uuidMap) {\n    if (myPair.first-&gt;getUUID().equals(uuid)) {\n      return myPair.first;\n    }\n  }\n  //return m_uuidMap.at(uuid.toString());\n  return nullptr;\n}  // getByUUID\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservicemapsetbyuuid","title":"BLEServiceMap::setByUUID","text":"<p>std::map <pre><code>void BLEServiceMap::setByUUID(BLEUUID uuid, BLEService *service) {\n  m_uuidMap.insert(std::pair&lt;BLEService *, String&gt;(service, uuid.toString())); // linked&lt;BLEService *, String&gt; m_uuidMap\n}  // setByUUID\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#stdmap","title":"std::map","text":"<pre><code>std::map&lt;BLEService *, String&gt; m_uuidMap;\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleserviceexecutecreate","title":"BLEService::executeCreate","text":"<p>esp_ble_gatts_create_service <pre><code>void BLEService::executeCreate(BLEServer *pServer) {\n  log_v(\"&gt;&gt; executeCreate() - Creating service (esp_ble_gatts_create_service) service uuid: %s\", getUUID().toString().c_str());\n  m_pServer = pServer;\n  m_semaphoreCreateEvt.take(\"executeCreate\");  // Take the mutex and release at event ESP_GATTS_CREATE_EVT\n\n  esp_gatt_srvc_id_t srvc_id;\n  srvc_id.is_primary = true;\n  srvc_id.id.inst_id = m_instId;\n  srvc_id.id.uuid = *m_uuid.getNative();\n  esp_err_t errRc =\n    ::esp_ble_gatts_create_service(getServer()-&gt;getGattsIf(), &amp;srvc_id, m_numHandles);  // The maximum number of handles associated with the service.\n//linked\n  if (errRc != ESP_OK) {\n    log_e(\"esp_ble_gatts_create_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n    return;\n  }\n\n  m_semaphoreCreateEvt.wait(\"executeCreate\");\n  log_v(\"&lt;&lt; executeCreate\");\n}  // executeCreate\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#server-createcharacteristic","title":"server-&gt;createCharacteristic","text":"<p>BLECharacteristic::BLECharacteristic addCharacteristic <pre><code>BLECharacteristic *BLEService::createCharacteristic(const char *uuid, uint32_t properties) {\n  return createCharacteristic(BLEUUID(uuid), properties);\n}\n\n/**\n * @brief Create a new BLE Characteristic associated with this service.\n * @param [in] uuid - The UUID of the characteristic.\n * @param [in] properties - The properties of the characteristic.\n * @return The new BLE characteristic.\n */\nBLECharacteristic *BLEService::createCharacteristic(BLEUUID uuid, uint32_t properties) {\n  BLECharacteristic *pCharacteristic = new BLECharacteristic(uuid, properties); //linked\n  addCharacteristic(pCharacteristic); //linked\n  return pCharacteristic;\n}  // createCharacteristic\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicblecharacteristic","title":"BLECharacteristic::BLECharacteristic","text":"<p>BLECharacteristic::setBroadcastProperty <pre><code>BLECharacteristic::BLECharacteristic(BLEUUID uuid, uint32_t properties) {\n  m_bleUUID = uuid;\n  m_handle = NULL_HANDLE;\n  m_properties = (esp_gatt_char_prop_t)0;\n  m_pCallbacks = &amp;defaultCallback;\n\n  setBroadcastProperty((properties &amp; PROPERTY_BROADCAST) != 0); //linked\n  setReadProperty((properties &amp; PROPERTY_READ) != 0);\n  setWriteProperty((properties &amp; PROPERTY_WRITE) != 0);\n  setNotifyProperty((properties &amp; PROPERTY_NOTIFY) != 0);\n  setIndicateProperty((properties &amp; PROPERTY_INDICATE) != 0);\n  setWriteNoResponseProperty((properties &amp; PROPERTY_WRITE_NR) != 0);\n}  // BLECharacteristic\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#addcharacteristic","title":"addCharacteristic","text":"<pre><code>void BLEService::addCharacteristic(BLECharacteristic *pCharacteristic) {\n  // We maintain a mapping of characteristics owned by this service.  These are managed by the\n  // BLECharacteristicMap class instance found in m_characteristicMap.  We add the characteristic\n  // to the map and then ask the service to add the characteristic at the BLE level (ESP-IDF).\n\n  log_v(\"&gt;&gt; addCharacteristic()\");\n  log_d(\"Adding characteristic: uuid=%s to service: %s\", pCharacteristic-&gt;getUUID().toString().c_str(), toString().c_str());\n\n  // Check that we don't add the same characteristic twice.\n  if (m_characteristicMap.getByUUID(pCharacteristic-&gt;getUUID()) != nullptr) {\n    log_w(\"&lt;&lt; Adding a new characteristic with the same UUID as a previous one\");\n    //return;\n  }\n\n  // Remember this characteristic in our map of characteristics.  At this point, we can lookup by UUID\n  // but not by handle.  The handle is allocated to us on the ESP_GATTS_ADD_CHAR_EVT.\n  m_characteristicMap.setByUUID(pCharacteristic, pCharacteristic-&gt;getUUID());\n\n  log_v(\"&lt;&lt; addCharacteristic()\");\n}  // addCharacteristic\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicsetbroadcastproperty","title":"BLECharacteristic::setBroadcastProperty","text":"<p>esp_gatt_char_prop_t <pre><code>void BLECharacteristic::setBroadcastProperty(bool value) {\n  //log_d(\"setBroadcastProperty(%d)\", value);\n  if (value) {\n    m_properties = (esp_gatt_char_prop_t)(m_properties | ESP_GATT_CHAR_PROP_BIT_BROADCAST); //linked m_properties;\n  } else {\n    m_properties = (esp_gatt_char_prop_t)(m_properties &amp; ~ESP_GATT_CHAR_PROP_BIT_BROADCAST);\n  }\n}  // setBroadcastProperty\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#ble2902","title":"BLE2902()","text":"<p>BLEDescriptor::setValue <pre><code>BLE2902::BLE2902() : BLEDescriptor(BLEUUID((uint16_t)0x2902)) {\n  uint8_t data[2] = {0, 0};\n  setValue(data, 2); //linked\n}  // BLE2902\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledescriptorsetvalue","title":"BLEDescriptor::setValue","text":"<p>esp_attr_value_t esp_ble_gatts_set_attr_value <pre><code>void BLEDescriptor::setValue(uint8_t *data, size_t length) {\n  if (length &gt; ESP_GATT_MAX_ATTR_LEN) {\n    log_e(\"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);\n    return;\n  }\n  m_value.attr_len = length; //linked m_value;\n  memcpy(m_value.attr_value, data, length);\n  if (m_handle != NULL_HANDLE) {\n    esp_ble_gatts_set_attr_value(m_handle, length, (const uint8_t *)data); //linked\n    log_d(\"Set the value in the GATTS database using handle 0x%x\", m_handle);\n  }\n}  // setValue\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#setnotifications","title":"setNotifications()","text":"<p>BLEDescriptor::getValue() <pre><code>void BLE2902::setNotifications(bool flag) {\n  uint8_t *pValue = getValue();\n  if (flag) {\n    pValue[0] |= 1 &lt;&lt; 0;\n  } else {\n    pValue[0] &amp;= ~(1 &lt;&lt; 0);\n  }\n  setValue(pValue, 2); //linked\n}  // setNotifications\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledescriptorgetvalue","title":"BLEDescriptor::getValue()","text":"<p>esp_attr_value_t <pre><code>uint8_t *BLEDescriptor::getValue() {\n  return m_value.attr_value; //linked m_value;\n}  // getValue\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#adddescriptor","title":"addDescriptor()","text":"<p>std::map <pre><code>void BLECharacteristic::addDescriptor(BLEDescriptor *pDescriptor) {//BLEDescriptor is the parent class of BLE2902\n  log_v(\"&gt;&gt; addDescriptor(): Adding %s to %s\", pDescriptor-&gt;toString().c_str(), toString().c_str());\n  m_descriptorMap.setByUUID(pDescriptor-&gt;getUUID(), pDescriptor); \n  //linked&lt;std::string, BLERemoteDescriptor *&gt; m_descriptorMap;\n  log_v(\"&lt;&lt; addDescriptor()\");\n}  // addDescriptor\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#stdmap_1","title":"std::map","text":"<pre><code>std::map&lt;std::string, BLERemoteDescriptor *&gt; m_descriptorMap;\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristic-setvalue","title":"BLECharacteristic-&gt;setValue()","text":"<p>BLECharacteristic::setValue <pre><code>void BLECharacteristic::setValue(String value) {\n  setValue((uint8_t *)(value.c_str()), value.length()); //linked\n}  // setValue\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicsetvalue","title":"BLECharacteristic::setValue","text":"<p>BLEValue BLEValue::setValue <pre><code>void BLECharacteristic::setValue(uint8_t *data, size_t length) {\n// The call to BLEUtils::buildHexData() doesn't output anything if the log level is not\n// \"VERBOSE\". As it is quite CPU intensive, it is much better to not call it if not needed.\n#if ARDUHAL_LOG_LEVEL &gt;= ARDUHAL_LOG_LEVEL_VERBOSE\n  char *pHex = BLEUtils::buildHexData(nullptr, data, length);\n  log_v(\"&gt;&gt; setValue: length=%d, data=%s, characteristic UUID=%s\", length, pHex, getUUID().toString().c_str());\n  free(pHex);\n#endif\n  if (length &gt; ESP_GATT_MAX_ATTR_LEN) {\n    log_e(\"Size %d too large, must be no bigger than %d\", length, ESP_GATT_MAX_ATTR_LEN);\n    return;\n  }\n  m_semaphoreSetValue.take();\n  m_value.setValue(data, length); //linked m_value; and linked\n  m_semaphoreSetValue.give();\n  log_v(\"&lt;&lt; setValue\");\n}  // setValue\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blevaluesetvalue","title":"BLEValue::setValue","text":"<pre><code>void BLEValue::setValue(String value) {\n  m_value = value;\n}  // setValue\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservice-start","title":"BLEservice-&gt;start()","text":"<p>BLECharacteristicMap BLECharacteristicMap::getFirst() BLECharacteristic::executeCreate BLECharacteristicMap::getNext esp_ble_gatts_start_service <pre><code>void BLEService::start() {\n  // We ask the BLE runtime to start the service and then create each of the characteristics.\n  // We start the service through its local handle which was returned in the ESP_GATTS_CREATE_EVT event\n  // obtained as a result of calling esp_ble_gatts_create_service().\n  //\n  log_v(\"&gt;&gt; start(): Starting service (esp_ble_gatts_start_service): %s\", toString().c_str());\n  if (m_handle == NULL_HANDLE) {\n    log_e(\"&lt;&lt; !!! We attempted to start a service but don't know its handle!\");\n    return;\n  }\n\n  BLECharacteristic *pCharacteristic = m_characteristicMap.getFirst(); //linked m_characteristicMap; and linked\n\n  while (pCharacteristic != nullptr) {\n    m_lastCreatedCharacteristic = pCharacteristic;\n    pCharacteristic-&gt;executeCreate(this); //linked\n\n    pCharacteristic = m_characteristicMap.getNext(); //linked\n  }\n  // Start each of the characteristics ... these are found in the m_characteristicMap.\n\n  m_semaphoreStartEvt.take(\"start\");\n  esp_err_t errRc = ::esp_ble_gatts_start_service(m_handle); //linked\n\n  if (errRc != ESP_OK) {\n    log_e(\"&lt;&lt; esp_ble_gatts_start_service: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n    return;\n  }\n  m_semaphoreStartEvt.wait(\"start\");\n\n  log_v(\"&lt;&lt; start()\");\n}  // start\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicexecutecreate","title":"BLECharacteristic::executeCreate","text":"<p>esp_attr_control_t esp_gatt_perm_t BLEDescriptor::BLEDescriptor BLEDescriptorMap BLEDescriptor::executeCreate <pre><code>void BLECharacteristic::executeCreate(BLEService *pService) {\n  log_v(\"&gt;&gt; executeCreate()\");\n\n  if (m_handle != NULL_HANDLE) {\n    log_e(\"Characteristic already has a handle.\");\n    return;\n  }\n\n  m_pService = pService;  // Save the service to which this characteristic belongs.\n\n  log_d(\"Registering characteristic (esp_ble_gatts_add_char): uuid: %s, service: %s\", getUUID().toString().c_str(), m_pService-&gt;toString().c_str());\n\n  esp_attr_control_t control; //linked\n  control.auto_rsp = ESP_GATT_RSP_BY_APP;\n\n  m_semaphoreCreateEvt.take(\"executeCreate\");\n  esp_err_t errRc = ::esp_ble_gatts_add_char(\n    m_pService-&gt;getHandle(), getUUID().getNative(), static_cast&lt;esp_gatt_perm_t&gt;(m_permissions), getProperties(), nullptr,\n    &amp;control\n  );  // Whether to auto respond or not.\n  //linked\n\n  if (errRc != ESP_OK) {\n    log_e(\"&lt;&lt; esp_ble_gatts_add_char: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n    return;\n  }\n  m_semaphoreCreateEvt.wait(\"executeCreate\");\n\n  BLEDescriptor *pDescriptor = m_descriptorMap.getFirst(); //linked and linked m_descriptorMap;\n  while (pDescriptor != nullptr) {\n    pDescriptor-&gt;executeCreate(this); //linked\n    pDescriptor = m_descriptorMap.getNext();\n  }  // End while\n\n  log_v(\"&lt;&lt; executeCreate\");\n}  // executeCreate\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledescriptorexecutecreate","title":"BLEDescriptor::executeCreate","text":"<p>esp_ble_gatts_add_char_descr <pre><code>void BLEDescriptor::executeCreate(BLECharacteristic *pCharacteristic) {\n  log_v(\"&gt;&gt; executeCreate(): %s\", toString().c_str());\n\n  if (m_handle != NULL_HANDLE) {\n    log_e(\"Descriptor already has a handle.\");\n    return;\n  }\n\n  m_pCharacteristic = pCharacteristic;  // Save the characteristic associated with this service.\n\n  esp_attr_control_t control;\n  control.auto_rsp = ESP_GATT_AUTO_RSP;\n  m_semaphoreCreateEvt.take(\"executeCreate\");\n  esp_err_t errRc =\n    ::esp_ble_gatts_add_char_descr(pCharacteristic-&gt;getService()-&gt;getHandle(), getUUID().getNative(), (esp_gatt_perm_t)m_permissions, &amp;m_value, &amp;control); //linked\n  if (errRc != ESP_OK) {\n    log_e(\"&lt;&lt; esp_ble_gatts_add_char_descr: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n    return;\n  }\n\n  m_semaphoreCreateEvt.wait(\"executeCreate\");\n  log_v(\"&lt;&lt; executeCreate\");\n}  // executeCreate\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledescriptormap","title":"BLEDescriptorMap","text":"<pre><code>class BLEDescriptorMap {\npublic:\n  void setByUUID(const char *uuid, BLEDescriptor *pDescriptor);\n  void setByUUID(BLEUUID uuid, BLEDescriptor *pDescriptor);\n  void setByHandle(uint16_t handle, BLEDescriptor *pDescriptor);\n  BLEDescriptor *getByUUID(const char *uuid);\n  BLEDescriptor *getByUUID(BLEUUID uuid);\n  BLEDescriptor *getByHandle(uint16_t handle);\n  String toString();\n  void handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param);\n  BLEDescriptor *getFirst();\n  BLEDescriptor *getNext();\n\nprivate:\n  std::map&lt;BLEDescriptor *, String&gt; m_uuidMap;\n  std::map&lt;uint16_t, BLEDescriptor *&gt; m_handleMap;\n  std::map&lt;BLEDescriptor *, String&gt;::iterator m_iterator;\n};\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledescriptorbledescriptor","title":"BLEDescriptor::BLEDescriptor","text":"<pre><code>BLEDescriptor::BLEDescriptor(BLEUUID uuid, uint16_t max_len) {\n  m_bleUUID = uuid;\n  m_value.attr_len = 0;            // Initial length is 0.\n  m_value.attr_max_len = max_len;  // Maximum length of the data.\n  m_handle = NULL_HANDLE;          // Handle is initially unknown.\n  m_pCharacteristic = nullptr;     // No initial characteristic.\n  m_pCallback = nullptr;           // No initial callback.\n\n  m_value.attr_value = (uint8_t *)malloc(max_len);  // Allocate storage for the value.\n}  // BLEDescriptor\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicmap","title":"BLECharacteristicMap","text":"<pre><code>class BLECharacteristicMap {\npublic:\n  void setByUUID(BLECharacteristic *pCharacteristic, const char *uuid);\n  void setByUUID(BLECharacteristic *pCharacteristic, BLEUUID uuid);\n  void setByHandle(uint16_t handle, BLECharacteristic *pCharacteristic);\n  BLECharacteristic *getByUUID(const char *uuid);\n  BLECharacteristic *getByUUID(BLEUUID uuid);\n  BLECharacteristic *getByHandle(uint16_t handle);\n  BLECharacteristic *getFirst();\n  BLECharacteristic *getNext();\n  String toString();\n  void handleGATTServerEvent(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if, esp_ble_gatts_cb_param_t *param);\n\nprivate:\n  std::map&lt;BLECharacteristic *, String&gt; m_uuidMap;\n  std::map&lt;uint16_t, BLECharacteristic *&gt; m_handleMap;\n  std::map&lt;BLECharacteristic *, String&gt;::iterator m_iterator;\n};\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicmapgetfirst","title":"BLECharacteristicMap::getFirst()","text":"<pre><code>BLECharacteristic *BLECharacteristicMap::getFirst() {\n  m_iterator = m_uuidMap.begin();\n  if (m_iterator == m_uuidMap.end()) {\n    return nullptr;\n  }\n  BLECharacteristic *pRet = m_iterator-&gt;first;\n  m_iterator++;\n  return pRet;\n}  // getFirst\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicmapgetnext","title":"BLECharacteristicMap::getNext","text":"<pre><code>BLECharacteristic *BLECharacteristicMap::getNext() {\n  if (m_iterator == m_uuidMap.end()) { //std::map&lt;BLECharacteristic *, String&gt; m_uuidMap;\n    return nullptr;\n  }\n  BLECharacteristic *pRet = m_iterator-&gt;first;\n  m_iterator++;\n  return pRet;\n}  // getNext\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledevicegetadvertising","title":"BLEDevice::getAdvertising","text":"<p>BLEAdvertising::BLEAdvertising() <pre><code>BLEAdvertising *BLEDevice::getAdvertising() {\n  if (m_bleAdvertising == nullptr) {\n    m_bleAdvertising = new BLEAdvertising(); //linked\n    log_i(\"create advertising\");\n  }\n  log_d(\"get advertising\");\n  return m_bleAdvertising;\n}\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleadvertisingbleadvertising","title":"BLEAdvertising::BLEAdvertising()","text":"<p>esp_ble_adv_data_t esp_ble_adv_params_t <pre><code>BLEAdvertising::BLEAdvertising() : m_scanRespData{} {\n  m_advData.set_scan_rsp = false; //linked m_advData;\n  m_advData.include_name = true;\n  m_advData.include_txpower = true;\n  m_advData.min_interval = 0x20;\n  m_advData.max_interval = 0x40;\n  m_advData.appearance = 0x00;\n  m_advData.manufacturer_len = 0;\n  m_advData.p_manufacturer_data = nullptr;\n  m_advData.service_data_len = 0;\n  m_advData.p_service_data = nullptr;\n  m_advData.service_uuid_len = 0;\n  m_advData.p_service_uuid = nullptr;\n  m_advData.flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT);\n\n  m_advParams.adv_int_min = 0x20; //linked m_advParams;\n  m_advParams.adv_int_max = 0x40;\n  m_advParams.adv_type = ADV_TYPE_IND;\n  m_advParams.own_addr_type = BLE_ADDR_TYPE_PUBLIC;\n  m_advParams.channel_map = ADV_CHNL_ALL;\n  m_advParams.adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY;\n  m_advParams.peer_addr_type = BLE_ADDR_TYPE_PUBLIC;\n\n  m_customAdvData = false;           // No custom advertising data\n  m_customScanResponseData = false;  // No custom scan response data\n}  // BLEAdvertising\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleadvertising-addserviceuuid","title":"BLEAdvertising-&gt;addServiceUUID()","text":"<pre><code>void BLEAdvertising::addServiceUUID(BLEUUID serviceUUID) {\n  m_serviceUUIDs.push_back(serviceUUID); //std::vector&lt;BLEUUID&gt; m_serviceUUIDs;\n}  // addServiceUUID\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservice-getuuid","title":"BLEService-&gt;getUUID()","text":"<pre><code>BLEUUID BLEService::getUUID() {\n  return m_uuid;\n}  // getUUID\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleadvertising-setscanresponse","title":"BLEAdvertising-&gt;setScanResponse()","text":"<pre><code>void BLEAdvertising::setScanResponse(bool set) {\n  m_scanResp = set;\n}\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleadvertising-setminmaxpreferred","title":"BLEAdvertising-&gt;setMin/MaxPreferred()","text":"<pre><code>void BLEAdvertising::setMinPreferred(uint16_t mininterval) {\n  m_advData.min_interval = mininterval;\n}  //\n\nvoid BLEAdvertising::setMaxPreferred(uint16_t maxinterval) {\n  m_advData.max_interval = maxinterval;\n}  //\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledevicestartadvertising","title":"BLEDevice::startAdvertising()","text":"<p>BLEDevice::getAdvertising <pre><code>void BLEDevice::startAdvertising() {\n  log_v(\"&gt;&gt; startAdvertising\");\n  getAdvertising()-&gt;start(); //linked\n  log_v(\"&lt;&lt; startAdvertising\");\n}  // startAdvertising\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bledevicegetadvertising_1","title":"BLEDevice::getAdvertising","text":"<p>BLEAdvertising::BLEAdvertising() <pre><code>BLEAdvertising *BLEDevice::getAdvertising() {\n  if (m_bleAdvertising == nullptr) {\n    m_bleAdvertising = new BLEAdvertising(); //linked\n    log_i(\"create advertising\");\n  }\n  log_d(\"get advertising\");\n  return m_bleAdvertising;\n}\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristic-notify","title":"BLECharacteristic-&gt;notify()","text":"<p>BLECharacteristic::getDescriptorByUUID BLE2902::getNotifications BLE2902::getIndications BLEServer::getPeerDevices esp_ble_gatts_send_indicate esp_gatt_status_t <pre><code>void BLECharacteristic::notify(bool is_notification) {\n  log_v(\"&gt;&gt; notify: length: %d\", m_value.getValue().length());\n\n  assert(getService() != nullptr);\n  assert(getService()-&gt;getServer() != nullptr);\n\n  m_pCallbacks-&gt;onNotify(this);  // Invoke the notify callback.\n\n  // GeneralUtils::hexDump() doesn't output anything if the log level is not\n  // \"VERBOSE\". Additionally, it is very CPU intensive, even when it doesn't\n  // output anything! So it is much better to *not* call it at all if not needed.\n  // In a simple program which calls BLECharacteristic::notify() every 50 ms,\n  // the performance gain of this little optimization is 37% in release mode\n  // (-O3) and 57% in debug mode.\n  // Of course, the \"#if ARDUHAL_LOG_LEVEL &gt;= ARDUHAL_LOG_LEVEL_VERBOSE\" guard\n  // could also be put inside the GeneralUtils::hexDump() function itself. But\n  // it's better to put it here also, as it is clearer (indicating a verbose log\n  // thing) and it allows to remove the \"m_value.getValue().c_str()\" call, which\n  // is, in itself, quite CPU intensive.\n#if ARDUHAL_LOG_LEVEL &gt;= ARDUHAL_LOG_LEVEL_VERBOSE\n  GeneralUtils::hexDump((uint8_t *)m_value.getValue().c_str(), m_value.getValue().length());\n#endif\n\n  if (getService()-&gt;getServer()-&gt;getConnectedCount() == 0) {\n    log_v(\"&lt;&lt; notify: No connected clients.\");\n    m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NO_CLIENT, 0);\n    return;\n  }\n\n  // Test to see if we have a 0x2902 descriptor.  If we do, then check to see if notification is enabled\n  // and, if not, prevent the notification.\n\n  BLE2902 *p2902 = (BLE2902 *)getDescriptorByUUID((uint16_t)0x2902); \n  //linked\n  if (is_notification) {\n    if (p2902 != nullptr &amp;&amp; !p2902-&gt;getNotifications()) { \n    //linked\n      log_v(\"&lt;&lt; notifications disabled; ignoring\");\n      m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_NOTIFY_DISABLED, 0);  // Invoke the notify callback.\n      return;\n    }\n  } else {\n    if (p2902 != nullptr &amp;&amp; !p2902-&gt;getIndications()) { //linked\n      log_v(\"&lt;&lt; indications disabled; ignoring\");\n      m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_DISABLED, 0);  // Invoke the notify callback.\n      return;\n    }\n  }\n  for (auto &amp;myPair : getService()-&gt;getServer()-&gt;getPeerDevices(false)) { \n  // linked\n    uint16_t _mtu = (myPair.second.mtu);\n    if (m_value.getValue().length() &gt; _mtu - 3) {\n      log_w(\"- Truncating to %d bytes (maximum notify size)\", _mtu - 3);\n    }\n\n    size_t length = m_value.getValue().length();\n    if (!is_notification) {  // is indication\n      m_semaphoreConfEvt.take(\"indicate\");\n    }\n    esp_err_t errRc = ::esp_ble_gatts_send_indicate( \n    //linked\n      getService()-&gt;getServer()-&gt;getGattsIf(), myPair.first, getHandle(), length, (uint8_t *)m_value.getValue().c_str(), !is_notification\n    );  // The need_confirm = false makes this a notify.\n    if (errRc != ESP_OK) {\n      log_e(\"&lt;&lt; esp_ble_gatts_send_ %s: rc=%d %s\", is_notification ? \"notify\" : \"indicate\", errRc, GeneralUtils::errorToString(errRc));\n      m_semaphoreConfEvt.give();\n      m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_GATT, errRc);  // Invoke the notify callback.\n      return;\n    }\n    if (!is_notification) {  // is indication\n      if (!m_semaphoreConfEvt.timedWait(\"indicate\", indicationTimeout)) {\n        m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_TIMEOUT, 0);  // Invoke the notify callback.\n      } else {\n        auto code = (esp_gatt_status_t)m_semaphoreConfEvt.value(); //linked\n        if (code == ESP_GATT_OK) {\n          m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_INDICATE, code);  // Invoke the notify callback.\n        } else {\n          m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::ERROR_INDICATE_FAILURE, code);\n        }\n      }\n    } else {\n      m_pCallbacks-&gt;onStatus(this, BLECharacteristicCallbacks::Status::SUCCESS_NOTIFY, 0);  // Invoke the notify callback.\n    }\n  }\n  log_v(\"&lt;&lt; notify\");\n}  // Notify\n</code></pre></p>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#blecharacteristicgetdescriptorbyuuid","title":"BLECharacteristic::getDescriptorByUUID","text":"<pre><code>BLEDescriptor *BLECharacteristic::getDescriptorByUUID(BLEUUID descriptorUUID) {\n  return m_descriptorMap.getByUUID(descriptorUUID);\n}  // getDescriptorByUUID\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#ble2902getnotifications","title":"BLE2902::getNotifications","text":"<pre><code>bool BLE2902::getNotifications() {\n  return (getValue()[0] &amp; (1 &lt;&lt; 0)) != 0;\n}  // getNotifications\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#ble2902getindications","title":"BLE2902::getIndications","text":"<pre><code>bool BLE2902::getIndications() {\n  return (getValue()[0] &amp; (1 &lt;&lt; 1)) != 0;\n}  // getIndications\n</code></pre>"},{"location":"Libraries/Arduino%20BLE%20Libraries/#bleservergetpeerdevices","title":"BLEServer::getPeerDevices","text":"<pre><code>std::map&lt;uint16_t, conn_status_t&gt; BLEServer::getPeerDevices(bool _client) {\n  return m_connectedServersMap; //std::map&lt;uint16_t, conn_status_t&gt; m_connectedServersMap;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/","title":"ESP IDF","text":""},{"location":"Libraries/ESP-IDF/#uuid-type","title":"UUID type","text":"<pre><code>typedef struct {\n#define ESP_UUID_LEN_16     2\n#define ESP_UUID_LEN_32     4\n#define ESP_UUID_LEN_128    16\n    uint16_t len;                           /* linked UUID length, 16bit, 32bit or 128bit */\n    union {\n        uint16_t    uuid16;                 /* linked 16bit UUID */\n        uint32_t    uuid32;                 /* linked 32bit UUID */\n        uint8_t     uuid128[ESP_UUID_LEN_128]; /* linked 128bit UUID */\n    } uuid;                                 /* linked UUID */\n} __attribute__((packed)) esp_bt_uuid_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_err_t","title":"esp_err_t","text":"<pre><code>typedef int esp_err_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_init","title":"nvs_flash_init","text":"<p>nvs_sec_cfg_t nvs_flash_read_security_cfg_v2 nvs_sec_scheme_t nvs_flash_generate_keys_v2 nvs_flash_secure_init nvs_flash_init_partition</p> <p>This API initialises the default NVS partition. The default NVS partition is the one that is labeled \"nvs\" in the partition table.</p> <p>When \"NVS_ENCRYPTION\" is enabled in the menuconfig, this API enables the NVS encryption for the default NVS partition as follows</p> <ol> <li> <p>Read security configurations from the first NVS key partition listed in the partition table. (NVS key partition is any \"data\" type partition which has the subtype value set to \"nvs_keys\")</p> </li> <li> <p>If the NVS key partition obtained in the previous step is empty, generate and store new keys in that NVS key partition.</p> </li> <li> <p>Internally call \"nvs_flash_secure_init()\" with the security configurations obtained/generated in the previous steps. <pre><code>extern \"C\" esp_err_t nvs_flash_init(void)\n{\n#ifdef CONFIG_NVS_ENCRYPTION\n    esp_err_t ret = ESP_FAIL;\n    nvs_sec_cfg_t cfg = {}; //[nvs_sec_cfg_t](ESP-IDF.md/#nvs_sec_cfg_t)\n\n    ret = nvs_flash_read_security_cfg_v2(&amp;nvs_sec_default_scheme_cfg, &amp;cfg);//[nvs_flash_read_security_cfg_v2](ESP-IDF.md/#nvs_flash_read_security_cfg_v2) and static [nvs_sec_scheme_t](ESP-IDF.md/#nvs_sec_scheme_t) nvs_sec_default_scheme_cfg;\n    if (ret != ESP_OK) {\n        ESP_LOGW(TAG, \"Failed to read NVS security cfg: [0x%02X] (%s)\", ret, esp_err_to_name(ret));\n        ESP_LOGI(TAG, \"Generating NVS encr-keys...\");\n        ret = nvs_flash_generate_keys_v2(&amp;nvs_sec_default_scheme_cfg, &amp;cfg); //[nvs_flash_generate_keys_v2](ESP-IDF.md/#nvs_flash_generate_keys_v2)\n        if (ret != ESP_OK) {\n            ESP_LOGE(TAG, \"Failed to generate NVS encr-keys: [0x%02X] (%s)\", ret, esp_err_to_name(ret));\n            return ret;\n        }\n    }\n\n    ret = nvs_flash_secure_init(&amp;cfg); //[nvs_flash_secure_init](ESP-IDF.md/#nvs_flash_secure_init)\n    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {\n        ESP_LOGE(TAG, \"Failed to initialize NVS partition: [0x%02X] (%s)\", ret, esp_err_to_name(ret));\n        return ret;\n    }\n    ESP_LOGI(TAG, \"NVS partition \\\"%s\\\" is encrypted.\", NVS_DEFAULT_PART_NAME);\n    return ret;\n#else // CONFIG_NVS_ENCRYPTION\n    return nvs_flash_init_partition(NVS_DEFAULT_PART_NAME); //[nvs_flash_init_partition](ESP-IDF.md/#nvs_flash_init_partition)\n#endif\n}\n</code></pre></p> </li> </ol>"},{"location":"Libraries/ESP-IDF/#nvs_sec_cfg_t","title":"nvs_sec_cfg_t","text":"<pre><code>typedef struct {\n    uint8_t eky[NVS_KEY_SIZE]; /* linked  XTS encryption and decryption key*/\n    uint8_t tky[NVS_KEY_SIZE]; /* linked  XTS tweak key */\n} nvs_sec_cfg_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_sec_scheme_t","title":"nvs_sec_scheme_t","text":"<pre><code>typedef struct\n{\n    int scheme_id;                                /* linked  Security Scheme ID (E.g. HMAC) */\n    void *scheme_data;                            /* linked  Scheme-specific data (E.g. eFuse block for HMAC-based key generation) */\n    nvs_flash_generate_keys_t nvs_flash_key_gen;  /* linked  Callback for the nvs_flash_key_gen implementation */\n    nvs_flash_read_cfg_t nvs_flash_read_cfg;      /* linked  Callback for the nvs_flash_read_keys implementation */\n} nvs_sec_scheme_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_init_partition","title":"nvs_flash_init_partition","text":"<p>Lock-init NVSPartitionManager-get_instance NVSPartitionManager-init_partition <pre><code>extern \"C\" esp_err_t nvs_flash_init_partition(const char *part_name)\n{\n    esp_err_t lock_result = Lock::init(); //[Lock-init](ESP-IDF.md/#lock-init)\n    if (lock_result != ESP_OK) {\n        return lock_result;\n    }\n    Lock lock;\n\n    assert(nvs::Page::SEC_SIZE == esp_partition_get_main_flash_sector_size());\n    return NVSPartitionManager::get_instance()-&gt;init_partition(part_name); //[NVSPartitionManager-get_instance](ESP-IDF.md/#nvspartitionmanager-get_instance) and [NVSPartitionManager-init_partition](ESP-IDF.md/#nvspartitionmanager-init_partition)\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#nvspartitionmanagerinit_partition","title":"NVSPartitionManager::init_partition","text":"<p>esp_partition_get_main_flash_sector_size lookup_storage_from_name NVSPartition <pre><code>esp_err_t NVSPartitionManager::init_partition(const char *partition_label)\n{\n    if (strlen(partition_label) &gt; NVS_PART_NAME_MAX_SIZE) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    uint32_t size;\n    const uint32_t sec_size = esp_partition_get_main_flash_sector_size(); //[esp_partition_get_main_flash_sector_size](ESP-IDF.md/#esp_partition_get_main_flash_sector_size)\n    Storage* mStorage;\n\n    mStorage = lookup_storage_from_name(partition_label); //[lookup_storage_from_name](ESP-IDF.md/#lookup_storage_from_name)\n    if (mStorage) {\n        return ESP_OK;\n    }\n\n    NVS_ASSERT_OR_RETURN(sec_size != 0, ESP_FAIL);\n\n    NVSPartition *p = nullptr; //[NVSPartition](ESP-IDF.md/#nvspartition)\n    esp_err_t result = partition_lookup::lookup_nvs_partition(partition_label, &amp;p);\n\n    if (result != ESP_OK) {\n        goto error;\n    }\n\n    size = p-&gt;get_size();\n\n    result = init_custom(p, 0, size / sec_size);\n    if (result != ESP_OK) {\n        goto error;\n    }\n\n    nvs_partition_list.push_back(p);\n\n    return ESP_OK;\n\nerror:\n    delete p;\n    return result;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#nvspartition","title":"NVSPartition","text":"<p>esp_partition_t <pre><code>NVSPartition::NVSPartition(const esp_partition_t* partition)\n        : mESPPartition(partition) //const [esp_partition_t](ESP-IDF.md/#esp_partition_t)* mESPPartition;\n{\n    // ensure the class is in a valid state\n    if (partition == nullptr) {\n        std::abort();\n    }\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_partition_t","title":"esp_partition_t","text":"<pre><code>typedef struct {\n    esp_flash_t* flash_chip;            /* linked SPI flash chip on which the partition resides */\n    esp_partition_type_t type;          /* linked partition type (app/data) */\n    esp_partition_subtype_t subtype;    /* linked partition subtype */\n    uint32_t address;                   /* linked starting address of the partition in flash */\n    uint32_t size;                      /* linked size of the partition, in bytes */\n    uint32_t erase_size;                /* linked size the erase operation should be aligned to */\n    char label[17];                     /* linked partition label, zero-terminated ASCII string */\n    bool encrypted;                     /* linked flag is set to true if partition is encrypted */\n    bool readonly;                      /* linked flag is set to true if partition is read-only */\n} esp_partition_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#lookup_storage_from_name","title":"lookup_storage_from_name","text":"<pre><code>static nvs::Storage* lookup_storage_from_name(const char *name)\n{\n    return NVSPartitionManager::get_instance()-&gt;lookup_storage_from_name(name);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_partition_get_main_flash_sector_size","title":"esp_partition_get_main_flash_sector_size","text":"<pre><code>uint32_t esp_partition_get_main_flash_sector_size(void)\n{\n    return SPI_FLASH_SEC_SIZE;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvspartitionmanagerget_instance","title":"NVSPartitionManager::get_instance","text":"<pre><code>NVSPartitionManager* NVSPartitionManager::get_instance()\n{\n    if (!instance) {\n        instance = new (std::nothrow) NVSPartitionManager();\n    }\n\n    return instance;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#lockinit","title":"Lock::init","text":"<pre><code>esp_err_t Lock::init()\n{\n    // Let postpone initialization to the Lock::Lock.\n    // It is designed to lazy initialize the semaphore in a properly guarded critical section\n    return ESP_OK;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_secure_init","title":"nvs_flash_secure_init","text":"<pre><code>extern \"C\" esp_err_t nvs_flash_secure_init_partition(const char *part_name, nvs_sec_cfg_t* cfg)\n{\n    esp_err_t lock_result = Lock::init();\n    if (lock_result != ESP_OK) {\n        return lock_result;\n    }\n    Lock lock;\n\n    assert(nvs::Page::SEC_SIZE == esp_partition_get_main_flash_sector_size());\n    return NVSPartitionManager::get_instance()-&gt;secure_init_partition(part_name, cfg);\n}\n\nextern \"C\" esp_err_t nvs_flash_secure_init(nvs_sec_cfg_t* cfg)\n{\n    return nvs_flash_secure_init_partition(NVS_DEFAULT_PART_NAME, cfg);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_generate_keys_v2","title":"nvs_flash_generate_keys_v2","text":"<pre><code>extern \"C\" esp_err_t nvs_flash_generate_keys_v2(nvs_sec_scheme_t *scheme_cfg, nvs_sec_cfg_t* cfg)\n{\n    if (scheme_cfg == nullptr || cfg == nullptr || scheme_cfg-&gt;nvs_flash_key_gen == nullptr) {\n        return ESP_ERR_INVALID_ARG;\n    }\n    return (scheme_cfg-&gt;nvs_flash_key_gen)(scheme_cfg-&gt;scheme_data, cfg);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_read_security_cfg_v2","title":"nvs_flash_read_security_cfg_v2","text":"<pre><code>extern \"C\" esp_err_t nvs_flash_read_security_cfg_v2(nvs_sec_scheme_t *scheme_cfg, nvs_sec_cfg_t* cfg)\n{\n    if (scheme_cfg == nullptr || cfg == nullptr || scheme_cfg-&gt;nvs_flash_read_cfg == nullptr) {\n        return ESP_ERR_INVALID_ARG;\n    }\n    return (scheme_cfg-&gt;nvs_flash_read_cfg)(scheme_cfg-&gt;scheme_data, cfg);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#nvs_flash_init_partition_1","title":"nvs_flash_init_partition","text":"<pre><code>extern \"C\" esp_err_t nvs_flash_init_partition(const char *part_name)\n{\n    esp_err_t lock_result = Lock::init();\n    if (lock_result != ESP_OK) {\n        return lock_result;\n    }\n    Lock lock;\n\n    assert(nvs::Page::SEC_SIZE == esp_partition_get_main_flash_sector_size());\n    return NVSPartitionManager::get_instance()-&gt;init_partition(part_name);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bt_controller_mem_release","title":"esp_bt_controller_mem_release","text":"<p>Memory Allocation <pre><code>esp_err_t esp_bt_controller_mem_release(esp_bt_mode_t mode) //[Memory Allocation](Telink.md/#memory-allocation)\n{\n    esp_err_t ret = ESP_OK;\n\n    if (btdm_controller_status != ESP_BT_CONTROLLER_STATUS_IDLE) {\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    if (mode == ESP_BT_MODE_BTDM) {\n        bt_area_t cont_bss = {\n            .start = (intptr_t)&amp;_bt_controller_bss_start,\n            .end   = (intptr_t)&amp;_bt_controller_bss_end,\n            .name  = \"BT Controller BSS\",\n        };\n        bt_area_t cont_data = {\n            .start = (intptr_t)&amp;_bt_controller_data_start,\n            .end   = (intptr_t)&amp;_bt_controller_data_end,\n            .name  = \"BT Controller Data\"\n        };\n\n        ret = esp_bt_mem_release_areas(&amp;cont_data, &amp;cont_bss);\n    }\n\n    if (ret == ESP_OK) {\n        ret = esp_bt_controller_rom_mem_release(mode);\n    }\n\n    return ret;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_bt_mode_t","title":"esp_bt_mode_t","text":"<pre><code>typedef enum {\n    ESP_BT_MODE_IDLE       = 0x00,   /* linked Bluetooth is not operating. */\n    ESP_BT_MODE_BLE        = 0x01,   /* linked Bluetooth is operating in BLE mode. */\n    ESP_BT_MODE_CLASSIC_BT = 0x02,   /* linked Bluetooth is operating in Classic Bluetooth mode. */\n    ESP_BT_MODE_BTDM       = 0x03,   /* linked Bluetooth is operating in Dual mode. */\n} esp_bt_mode_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bt_controller_config_t","title":"esp_bt_controller_config_t","text":"<pre><code>typedef struct {\n    uint16_t controller_task_stack_size;    /* linked Bluetooth Controller task stack size in bytes */\n    uint8_t controller_task_prio;           /* linked Bluetooth Controller task priority */\n    uint8_t hci_uart_no;                    /* linked UART number as HCI I/O interface. Configurable in menuconfig.\n                                                - 1 - URAT 1 (default)\n                                                - 2 - URAT 2 */\n    uint32_t hci_uart_baudrate;             /* linked  UART baudrate. Configurable in menuconfig.\n                                                - Range: 115200 - 921600\n                                                - Default: 921600 */\n    uint8_t scan_duplicate_mode;            /* linked Scan duplicate filtering mode. Configurable in menuconfig.\n                                                - 0 - Normal scan duplicate filtering mode (default)\n                                                - 1 - Special scan duplicate filtering mode for BLE Mesh */\n    uint8_t scan_duplicate_type;            /* linked Scan duplicate filtering type. If `scan_duplicate_mode` is set to 1, this parameter will be ignored. Configurable in menuconfig.\n                                                - 0 - Filter scan duplicates by device address only (default)\n                                                - 1 - Filter scan duplicates by advertising data only, even if they originate from different devices.\n                                                - 2 - Filter scan duplicated by device address and advertising data. */\n    uint16_t normal_adv_size;               /* linked Maximum number of devices in scan duplicate filtering list. Configurable in menuconfig\n                                                - Range: 10 - 1000\n                                                - Default: 100 */\n    uint16_t mesh_adv_size;                 /* linked Maximum number of Mesh advertising packets in scan duplicate filtering list. Configurable in menuconfig\n                                                - Range: 10 - 1000\n                                                - Default: 100 */\n    uint16_t send_adv_reserved_size;        /* linked Controller minimum memory value in bytes. Internal use only */\n    uint32_t  controller_debug_flag;        /* linked Controller debug log flag. Internal use only */\n    uint8_t mode;                           /* linked Controller mode.  Configurable in menuconfig\n                                                - 1 - BLE mode\n                                                - 2 - Classic Bluetooth mode\n                                                - 3 - Dual mode\n                                                - 4 - Others: Invalid */\n    uint8_t ble_max_conn;                   /* linked Maximum number of BLE connections. Configurable in menuconfig\n                                                - Range: 1 - 9\n                                                - Default: 3 */\n    uint8_t bt_max_acl_conn;                /* linked Maximum number of BR/EDR ACL connections. Configurable in menuconfig\n                                                - Range: 1 - 7\n                                                - Default: 2 */\n    uint8_t bt_sco_datapath;                /* linked SCO data path. Configurable in menuconfig\n                                                - 0 - HCI module (default)\n                                                - 1 - PCM module */\n    bool auto_latency;                      /* linked True if BLE auto latency is enabled, used to enhance Classic Bluetooth performance in the Dual mode; false otherwise (default). Configurable in menuconfig */\n    bool bt_legacy_auth_vs_evt;             /* linked True if BR/EDR Legacy Authentication Vendor Specific Event is enabled (default in the classic bluetooth or Dual mode), which is required to protect from BIAS attack; false otherwise. Configurable in menuconfig */\n    uint8_t bt_max_sync_conn;               /* linked Maximum number of BR/EDR synchronous connections. Configurable in menuconfig\n                                                - Range: 0 - 3\n                                                - Default: 0 */\n    uint8_t ble_sca;                        /* linked BLE low power crystal accuracy index. Configurable in menuconfig\n                                                - 0 - `BTDM_BLE_DEFAULT_SCA_500PPM`\n                                                - 1 - `BTDM_BLE_DEFAULT_SCA_250PPM` (default) */\n    uint8_t pcm_role;                       /* linked PCM role. Configurable in menuconfig\n                                                - 0 - PCM master (default)\n                                                - 1 - PCM slave (default) */\n    uint8_t pcm_polar;                      /* linked PCM polarity (falling clk edge &amp; rising clk edge). Configurable in menuconfig\n                                                - 0 - Falling Edge (default)\n                                                - 1 - Rising Edge */\n    uint8_t pcm_fsyncshp;                   /* linked Physical shape of the PCM Frame Synchronization signal. Configurable in menuconfig\n                                                - 0 - Stereo Mode (default)\n                                                - 1 - Mono Mode 1\n                                                - 2 - Mono Mode 2 */\n    bool hli;                               /* linked True if using high-level (level 4) interrupt (default); false otherwise. Configurable in menuconfig */\n    uint8_t enc_key_sz_min;                 /* linked Minimum size of the encryption key\n                                                - Range: 7 - 16\n                                                - Default: 7 */\n    uint16_t dup_list_refresh_period;       /* linked Scan duplicate filtering list refresh period in seconds. Configurable in menuconfig\n                                                - Range: 0 - 100 seconds\n                                                - Default: 0 second */\n    bool ble_scan_backoff;                  /* linked True if BLE scan backoff is enabled; false otherwise (default). Configurable in menuconfig */\n    uint8_t ble_llcp_disc_flag;             /* linked Flag indicating whether the Controller disconnects after Instant Passed (0x28) error occurs. Configurable in menuconfig.\n                                                - The Controller does not disconnect after Instant Passed (0x28) by default. */\n    bool ble_aa_check;                      /* linked True if adds a verification step for the Access Address within the `CONNECT_IND` PDU; false otherwise (default). Configurable in menuconfig */\n    uint8_t ble_chan_ass_en;                /* linked True if BLE channel assessment is enabled (default), false otherwise. Configurable in menuconfig */\n    uint8_t ble_ping_en;                    /* linked True if BLE ping procedure is enabled (default), false otherwise. Configurable in menuconfig */\n    uint32_t magic;                         /* linked Magic number */\n} esp_bt_controller_config_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#bt_controller_init_config_default","title":"BT_CONTROLLER_INIT_CONFIG_DEFAULT","text":"<pre><code>#define BT_CONTROLLER_INIT_CONFIG_DEFAULT() {                              \\\n    .controller_task_stack_size = ESP_TASK_BT_CONTROLLER_STACK,            \\\n    .controller_task_prio = ESP_TASK_BT_CONTROLLER_PRIO,                   \\\n    .hci_uart_no = BT_HCI_UART_NO_DEFAULT,                                 \\\n    .hci_uart_baudrate = BT_HCI_UART_BAUDRATE_DEFAULT,                     \\\n    .scan_duplicate_mode = SCAN_DUPLICATE_MODE,                            \\\n    .scan_duplicate_type = SCAN_DUPLICATE_TYPE_VALUE,                      \\\n    .normal_adv_size = NORMAL_SCAN_DUPLICATE_CACHE_SIZE,                   \\\n    .mesh_adv_size = MESH_DUPLICATE_SCAN_CACHE_SIZE,                       \\\n    .send_adv_reserved_size = SCAN_SEND_ADV_RESERVED_SIZE,                 \\\n    .controller_debug_flag = BTDM_CTRL_CONTROLLER_DEBUG_FLAG,              \\\n    .mode = BTDM_CONTROLLER_MODE_EFF,                                      \\\n    .ble_max_conn = CONFIG_BTDM_CTRL_BLE_MAX_CONN_EFF,                     \\\n    .bt_max_acl_conn = CONFIG_BTDM_CTRL_BR_EDR_MAX_ACL_CONN_EFF,           \\\n    .bt_sco_datapath = CONFIG_BTDM_CTRL_BR_EDR_SCO_DATA_PATH_EFF,          \\\n    .auto_latency = BTDM_CTRL_AUTO_LATENCY_EFF,                            \\\n    .bt_legacy_auth_vs_evt = BTDM_CTRL_LEGACY_AUTH_VENDOR_EVT_EFF,         \\\n    .bt_max_sync_conn = CONFIG_BTDM_CTRL_BR_EDR_MAX_SYNC_CONN_EFF,         \\\n    .ble_sca = CONFIG_BTDM_BLE_SLEEP_CLOCK_ACCURACY_INDEX_EFF,             \\\n    .pcm_role = CONFIG_BTDM_CTRL_PCM_ROLE_EFF,                             \\\n    .pcm_polar = CONFIG_BTDM_CTRL_PCM_POLAR_EFF,                           \\\n    .pcm_fsyncshp = CONFIG_BTDM_CTRL_PCM_FSYNCSHP_EFF,                     \\\n    .hli = BTDM_CTRL_HLI,                                                  \\\n    .enc_key_sz_min = CONFIG_BTDM_CTRL_BR_EDR_MIN_ENC_KEY_SZ_DFT_EFF,      \\\n    .dup_list_refresh_period = SCAN_DUPL_CACHE_REFRESH_PERIOD,             \\\n    .ble_scan_backoff = BTDM_CTRL_SCAN_BACKOFF_UPPERLIMITMAX,              \\\n    .ble_llcp_disc_flag = BTDM_BLE_LLCP_DISC_FLAG,                         \\\n    .ble_aa_check = BTDM_CTRL_CHECK_CONNECT_IND_ACCESS_ADDRESS_ENABLED,    \\\n    .ble_chan_ass_en = BTDM_BLE_CHAN_ASS_EN,                               \\\n    .ble_ping_en = BTDM_BLE_PING_EN,                                       \\\n    .magic = ESP_BT_CONTROLLER_CONFIG_MAGIC_VAL,                           \\\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bt_controller_init","title":"esp_bt_controller_init","text":"<p>Controller Init <pre><code>esp_err_t esp_bt_controller_init(esp_bt_controller_config_t *cfg) //[Controller Init](Telink.md/#controller-init)\n{\n    esp_err_t err;\n    uint32_t btdm_cfg_mask = 0;\n\n#if CONFIG_BTDM_CTRL_HLI\n    hli_queue_setup_pinned_to_core(CONFIG_BTDM_CTRL_PINNED_TO_CORE);\n#endif /* CONFIG_BTDM_CTRL_HLI */\n\n    //if all the bt available memory was already released, cannot initialize bluetooth controller\n    if (btdm_dram_available_region[0].mode == ESP_BT_MODE_IDLE) {\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    osi_funcs_p = (struct osi_funcs_t *)malloc_internal_wrapper(sizeof(struct osi_funcs_t));\n    if (osi_funcs_p == NULL) {\n        return ESP_ERR_NO_MEM;\n    }\n\n    memcpy(osi_funcs_p, &amp;osi_funcs_ro, sizeof(struct osi_funcs_t));\n    if (btdm_osi_funcs_register(osi_funcs_p) != 0) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (btdm_controller_status != ESP_BT_CONTROLLER_STATUS_IDLE) {\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    if (cfg == NULL) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (cfg-&gt;controller_task_prio != ESP_TASK_BT_CONTROLLER_PRIO\n            || cfg-&gt;controller_task_stack_size &lt; ESP_TASK_BT_CONTROLLER_STACK) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    //overwrite some parameters\n    cfg-&gt;bt_max_sync_conn = CONFIG_BTDM_CTRL_BR_EDR_MAX_SYNC_CONN_EFF;\n    cfg-&gt;magic  = ESP_BT_CONTROLLER_CONFIG_MAGIC_VAL;\n\n    if (((cfg-&gt;mode &amp; ESP_BT_MODE_BLE) &amp;&amp; (cfg-&gt;ble_max_conn &lt;= 0 || cfg-&gt;ble_max_conn &gt; BTDM_CONTROLLER_BLE_MAX_CONN_LIMIT))\n            || ((cfg-&gt;mode &amp; ESP_BT_MODE_CLASSIC_BT) &amp;&amp; (cfg-&gt;bt_max_acl_conn &lt;= 0 || cfg-&gt;bt_max_acl_conn &gt; BTDM_CONTROLLER_BR_EDR_MAX_ACL_CONN_LIMIT))\n            || ((cfg-&gt;mode &amp; ESP_BT_MODE_CLASSIC_BT) &amp;&amp; (cfg-&gt;bt_max_sync_conn &gt; BTDM_CONTROLLER_BR_EDR_MAX_SYNC_CONN_LIMIT))) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    ESP_LOGI(BTDM_LOG_TAG, \"BT controller compile version [%s]\", btdm_controller_get_compile_version());\n\n    s_wakeup_req_sem = semphr_create_wrapper(1, 0);\n    if (s_wakeup_req_sem == NULL) {\n        err = ESP_ERR_NO_MEM;\n        goto error;\n    }\n\n    esp_phy_modem_init();\n\n    esp_bt_power_domain_on();\n\n    btdm_controller_mem_init();\n\n    periph_module_enable(PERIPH_BT_MODULE);\n    periph_module_reset(PERIPH_BT_MODULE);\n\n#if CONFIG_BTDM_CTRL_HCI_UART_FLOW_CTRL_EN\n    sdk_config_set_uart_flow_ctrl_enable(true);\n#else\n    sdk_config_set_uart_flow_ctrl_enable(false);\n#endif\n\n    if ((err = btdm_low_power_mode_init()) != ESP_OK) {\n        ESP_LOGE(BTDM_LOG_TAG, \"Low power module initialization failed\");\n        goto error;\n    }\n\n#if CONFIG_SW_COEXIST_ENABLE\n    coex_init();\n#endif\n\n#if CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED\n    if (ble_log_spi_out_init() != 0) {\n        ESP_LOGE(BTDM_LOG_TAG, \"BLE Log SPI output init failed\");\n        err = ESP_ERR_NO_MEM;\n        goto error;\n    }\n#endif // CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED\n\n    btdm_cfg_mask = btdm_config_mask_load();\n\n    err = btdm_controller_init(btdm_cfg_mask, cfg);\n\n    if (err != 0) {\n        ESP_LOGE(BTDM_LOG_TAG, \"%s %d\\n\",__func__,err);\n        err = ESP_ERR_NO_MEM;\n        goto error;\n    }\n\n#ifdef CONFIG_BT_BLUEDROID_ENABLED\n    bt_stack_enableSecCtrlVsCmd(true);\n#endif // CONFIG_BT_BLUEDROID_ENABLED\n#if defined(CONFIG_BT_NIMBLE_ENABLED) || defined(CONFIG_BT_BLUEDROID_ENABLED)\n    bt_stack_enableCoexVsCmd(true);\n    scan_stack_enableAdvFlowCtrlVsCmd(true);\n    adv_stack_enableClearLegacyAdvVsCmd(true);\n    advFilter_stack_enableDupExcListVsCmd(true);\n#endif // (CONFIG_BT_NIMBLE_ENABLED) || (CONFIG_BT_BLUEDROID_ENABLED)\n\n    btdm_controller_status = ESP_BT_CONTROLLER_STATUS_INITED;\n\n    return ESP_OK;\n\nerror:\n\n#if CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED\n    ble_log_spi_out_deinit();\n#endif // CONFIG_BT_BLE_LOG_SPI_OUT_ENABLED\n\n    bt_controller_deinit_internal();\n\n    return err;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_bt_controller_enable","title":"esp_bt_controller_enable","text":"<pre><code>esp_err_t esp_bt_controller_enable(esp_bt_mode_t mode)\n{\n    int ret;\n\n    if (btdm_controller_status != ESP_BT_CONTROLLER_STATUS_INITED) {\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    //As the history reason, mode should be equal to the mode which set in esp_bt_controller_init()\n    if (mode != btdm_controller_get_mode()) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n#ifdef CONFIG_PM_ENABLE\n    if (!s_btdm_allow_light_sleep) {\n        esp_pm_lock_acquire(s_light_sleep_pm_lock);\n    }\n    esp_pm_lock_acquire(s_pm_lock);\n#endif\n\n    esp_phy_enable(PHY_MODEM_BT);\n\n#if CONFIG_SW_COEXIST_ENABLE\n    coex_enable();\n#endif\n\n    if (btdm_controller_get_sleep_mode() == BTDM_MODEM_SLEEP_MODE_ORIG) {\n        btdm_controller_enable_sleep(true);\n    }\n\n    sdk_config_set_bt_pll_track_enable(true);\n\n    // initialize bluetooth baseband\n    btdm_check_and_init_bb();\n\n    ret = btdm_controller_enable(mode);\n    if (ret != 0) {\n#if CONFIG_SW_COEXIST_ENABLE\n        coex_disable();\n#endif\n        esp_phy_disable(PHY_MODEM_BT);\n#ifdef CONFIG_PM_ENABLE\n        if (!s_btdm_allow_light_sleep) {\n            esp_pm_lock_release(s_light_sleep_pm_lock);\n        }\n        esp_pm_lock_release(s_pm_lock);\n#endif\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    btdm_controller_status = ESP_BT_CONTROLLER_STATUS_ENABLED;\n    ret = esp_register_shutdown_handler(bt_shutdown);\n    if (ret != ESP_OK) {\n        ESP_LOGW(BTDM_LOG_TAG, \"Register shutdown handler failed, ret = 0x%x\", ret);\n    }\n\n    return ESP_OK;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_status_t","title":"esp_bluedroid_status_t","text":"<pre><code>typedef enum {\n    ESP_BLUEDROID_STATUS_UNINITIALIZED   = 0,        /* linked Bluetooth not initialized */\n    ESP_BLUEDROID_STATUS_INITIALIZED,                /* linked Bluetooth initialized but not enabled */\n    ESP_BLUEDROID_STATUS_ENABLED                     /* linked Bluetooth initialized and enabled */\n} esp_bluedroid_status_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_get_status","title":"esp_bluedroid_get_status","text":"<pre><code>esp_bluedroid_status_t esp_bluedroid_get_status(void)\n{\n    if (bd_already_init) {\n        if (bd_already_enable) {\n            return ESP_BLUEDROID_STATUS_ENABLED;\n        } else {\n            return ESP_BLUEDROID_STATUS_INITIALIZED;\n        }\n    } else {\n        return ESP_BLUEDROID_STATUS_UNINITIALIZED;\n    }\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_init","title":"esp_bluedroid_init","text":"<p>Bluetooth stack init esp_bluedroid_config_t BT_BLUEDROID_INIT_CONFIG_DEFAULT esp_bluedroid_init_with_cfg <pre><code>esp_err_t esp_bluedroid_init(void) //[Bluetooth stack init](Telink.md/#bluetooth-stack-init)\n{\n    esp_bluedroid_config_t cfg = BT_BLUEDROID_INIT_CONFIG_DEFAULT(); //[esp_bluedroid_config_t](ESP-IDF.md/#esp_bluedroid_config_t) and [BT_BLUEDROID_INIT_CONFIG_DEFAULT](ESP-IDF.md/#bt_bluedroid_init_config_default)\n    return esp_bluedroid_init_with_cfg(&amp;cfg); //[esp_bluedroid_init_with_cfg](ESP-IDF.md/#esp_bluedroid_init_with_cfg)\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_config_t","title":"esp_bluedroid_config_t","text":"<pre><code>typedef struct {\n    bool ssp_en; /* linked Whether SSP(secure simple pairing) or legacy pairing is used for Classic Bluetooth */\n    bool sc_en; /* linked Whether secure connection host support is enabled or disabled for Classic Bluetooth */\n} esp_bluedroid_config_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#bt_bluedroid_init_config_default","title":"BT_BLUEDROID_INIT_CONFIG_DEFAULT","text":"<pre><code>#define BT_BLUEDROID_INIT_CONFIG_DEFAULT()                                                                             \\\n    {                                                                                                                  \\\n        .ssp_en = true,                                                                                                \\\n        .sc_en = false,                                                                                                \\\n    }\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_init_with_cfg","title":"esp_bluedroid_init_with_cfg","text":"<p>Bluetooth stack configs btc_msg bluedroid_config_init btc_init btc_main_get_future_p future_new btc_transfer_context future_await <pre><code>esp_err_t esp_bluedroid_init_with_cfg(esp_bluedroid_config_t *cfg) //[Bluetooth stack configs](Telink.md/#bluetooth-stack-configs)\n{\n    btc_msg_t msg; //[btc_msg](ESP-IDF.md/#btc_msg)\n    future_t **future_p;\n    bt_status_t ret;\n\n    if (!cfg) {\n        LOG_ERROR(\"%s cfg is NULL\", __func__);\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    if (cfg-&gt;sc_en) {\n#if (SC_MODE_INCLUDED == FALSE)\n        LOG_ERROR(\"Secure Connections should not be enabled when target controller is ESP32.\\n\");\n        LOG_ERROR(\"It may trigger unresolved bugs in the controller.\\n\");\n        return ESP_ERR_INVALID_ARG;\n#endif // SC_MODE_INCLUDED\n\n        if (!cfg-&gt;ssp_en) {\n            LOG_ERROR(\"secure simple pairing should be enabled when secure connection host support is enabled\\n\");\n            return ESP_ERR_INVALID_ARG;\n        }\n\n        LOG_WARN(\"Please make sure to clear the bond list before enabling the secure connection host support\\n\");\n    }\n\n#if (BT_CONTROLLER_INCLUDED == TRUE)\n    if (esp_bt_controller_get_status() != ESP_BT_CONTROLLER_STATUS_ENABLED) {\n        LOG_ERROR(\"Controller not initialised\\n\");\n        return ESP_ERR_INVALID_STATE;\n    }\n#endif\n\n    if (bd_already_init) {\n        LOG_ERROR(\"Bluedroid already initialised\\n\");\n        return ESP_ERR_INVALID_STATE;\n    }\n\n#if HEAP_MEMORY_DEBUG\n    osi_mem_dbg_init();\n#endif\n\n    ret = bluedroid_config_init(cfg); //[bluedroid_config_init](ESP-IDF.md/#bluedroid_config_init)\n    if (ret != BT_STATUS_SUCCESS) {\n        LOG_ERROR(\"Bluedroid stack initialize fail, ret:%d\", ret);\n        return ESP_FAIL;\n    }\n\n    /*\n     * BTC Init\n     */\n    ret = btc_init(); //[btc_init](ESP-IDF.md/#btc_init)\n    if (ret != BT_STATUS_SUCCESS) {\n        LOG_ERROR(\"Bluedroid Initialize Fail\");\n        return ESP_FAIL;\n    }\n\n    future_p = btc_main_get_future_p(BTC_MAIN_INIT_FUTURE); //[btc_main_get_future_p](ESP-IDF.md/#btc_main_get_future_p)\n    *future_p = future_new(); //[future_new](ESP-IDF.md/#future_new)\n    if (*future_p == NULL) {\n        LOG_ERROR(\"Bluedroid Initialize Fail!\");\n        return ESP_ERR_NO_MEM;\n    }\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_MAIN_INIT;\n    msg.act = BTC_MAIN_ACT_INIT;\n\n    if (btc_transfer_context(&amp;msg, NULL, 0, NULL, NULL) != BT_STATUS_SUCCESS) // [btc_transfer_context](ESP-IDF.md/#btc_transfer_context)\n    {\n        LOG_ERROR(\"Bluedroid Initialize Fail\");\n        return ESP_FAIL;\n    }\n\n    if (future_await(*future_p) == FUTURE_FAIL) { //[future_await](ESP-IDF.md/#future_await)\n        LOG_ERROR(\"Bluedroid Initialize Fail\");\n        return ESP_FAIL;\n    }\n\n    bd_already_init = true;\n\n#if (BT_HCI_LOG_INCLUDED == TRUE)\n    bt_hci_log_init();\n#endif // (BT_HCI_LOG_INCLUDED == TRUE)\n\n    return ESP_OK;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#bluedroid_config_init","title":"bluedroid_config_init","text":"<pre><code>bt_status_t bluedroid_config_init(esp_bluedroid_config_t *cfg)\n{\n    s_stack_config_env = osi_calloc(sizeof(struct stack_config_env_tag));\n    if (!s_stack_config_env) {\n        return BT_STATUS_NOMEM;\n    }\n\n    memcpy(&amp;s_stack_config_env-&gt;cfg, cfg, sizeof(esp_bluedroid_config_t));\n\n    struct bluedroid_config *interface = &amp;s_stack_config_env-&gt;interface;\n    interface-&gt;get_ssp_enabled = get_ssp_enabled;\n    interface-&gt;get_sc_enabled = get_sc_enabled;\n\n    return BT_STATUS_SUCCESS;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#btc_init","title":"btc_init","text":"<p>Task Controller <pre><code>bt_status_t btc_init(void) //[Task Controller](Telink.md/#task-controller)\n{\n    const size_t workqueue_len[] = {BTC_TASK_WORKQUEUE0_LEN, BTC_TASK_WORKQUEUE1_LEN};\n    btc_thread = osi_thread_create(BTC_TASK_NAME, BTC_TASK_STACK_SIZE, BTC_TASK_PRIO, BTC_TASK_PINNED_TO_CORE,\n                                   BTC_TASK_WORKQUEUE_NUM, workqueue_len);\n    if (btc_thread == NULL) {\n        return BT_STATUS_NOMEM;\n    }\n\n#if BTC_DYNAMIC_MEMORY\n    if (btc_init_mem() != BT_STATUS_SUCCESS){\n        return BT_STATUS_NOMEM;\n    }\n#endif\n#if BTC_GAP_BT_INCLUDED\n    btc_gap_bt_init();\n#endif\n\n#if (BLE_INCLUDED == TRUE)\n    btc_gap_callback_init();\n#if (BLE_FEAT_ISO_EN == TRUE)\n    btc_iso_callback_init();\n#endif // #if (BLE_FEAT_ISO_EN == TRUE)\n#if (BLE_FEAT_CTE_EN == TRUE)\n    btc_cte_callback_init();\n#endif // #if (BLE_FEAT_CTE_EN == TRUE)\n    btc_gap_ble_init();\n#endif  ///BLE_INCLUDED == TRUE\n\n    /* TODO: initial the profile_tab */\n    return BT_STATUS_SUCCESS;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#btc_main_get_future_p","title":"btc_main_get_future_p","text":"<p>Future pointer <pre><code>future_t **btc_main_get_future_p(btc_main_future_type_t type) //[Future pointer](Telink.md/#future-pointer)\n{\n    return &amp;main_future[type];\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#future_new","title":"future_new","text":"<p>tlkos_semphr_createBinary <pre><code>future_t *future_new(void) //[tlkos_semphr_createBinary](Telink.md/#tlkos_semphr_createbinary)\n{\n    future_t *ret = osi_calloc(sizeof(future_t));\n    if (!ret) {\n        OSI_TRACE_ERROR(\"%s unable to allocate memory for return value.\", __func__);\n        goto error;\n    }\n\n    if (osi_sem_new(&amp;ret-&gt;semaphore, 1, 0) != 0) {\n        OSI_TRACE_ERROR(\"%s unable to allocate memory for the semaphore.\", __func__);\n        goto error;\n    }\n\n    ret-&gt;ready_can_be_called = true;\n    return ret;\nerror:;\n    future_free(ret);\n    return NULL;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#btc_msg","title":"btc_msg","text":"<pre><code>typedef struct btc_msg {\n    uint8_t sig;    //event signal\n    uint8_t aid;    //application id\n    uint8_t pid;    //profile id\n    uint8_t act;    //profile action, defined in seprerate header files\n    UINT8   arg[0]; //param for btc function or function param\n} btc_msg_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#btc_transfer_context","title":"btc_transfer_context","text":"<p>tlksys_task_input <pre><code>bt_status_t btc_transfer_context(btc_msg_t *msg, void *arg, int arg_len, btc_arg_deep_copy_t copy_func,\n                                    btc_arg_deep_free_t free_func) //[tlksys_task_input](ESP-IDF.md/#tlksys_task_input)\n{\n    btc_msg_t* lmsg;\n    bt_status_t ret;\n    //                              arg XOR arg_len\n    if ((msg == NULL) || ((arg == NULL) == !(arg_len == 0))) {\n        BTC_TRACE_WARNING(\"%s Invalid parameters\\n\", __func__);\n        return BT_STATUS_PARM_INVALID;\n    }\n\n    BTC_TRACE_DEBUG(\"%s msg %u %u %u %p\\n\", __func__, msg-&gt;sig, msg-&gt;pid, msg-&gt;act, arg);\n\n    lmsg = (btc_msg_t *)osi_malloc(sizeof(btc_msg_t) + arg_len);\n    if (lmsg == NULL) {\n        BTC_TRACE_WARNING(\"%s No memory\\n\", __func__);\n        return BT_STATUS_NOMEM;\n    }\n\n    memcpy(lmsg, msg, sizeof(btc_msg_t));\n    if (arg) {\n        memset(lmsg-&gt;arg, 0x00, arg_len);    //important, avoid arg which have no length\n        memcpy(lmsg-&gt;arg, arg, arg_len);\n        if (copy_func) {\n            copy_func(lmsg, lmsg-&gt;arg, arg);\n        }\n    }\n\n    ret = btc_task_post(lmsg, OSI_THREAD_MAX_TIMEOUT);\n    if (ret != BT_STATUS_SUCCESS) {\n        if (copy_func &amp;&amp; free_func) {\n            free_func(lmsg);\n        }\n        osi_free(lmsg);\n    }\n\n    return ret;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#future_await","title":"future_await","text":"<pre><code>void *future_await(future_t *future)\n{\n    assert(future != NULL);\n\n    // If the future is immediate, it will not have a semaphore\n    if (future-&gt;semaphore) {\n        osi_sem_take(&amp;future-&gt;semaphore, OSI_SEM_MAX_TIMEOUT);\n    }\n\n    void *result = future-&gt;result;\n    future_free(future);\n    return result;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_bluedroid_enable","title":"esp_bluedroid_enable","text":"<p>tlkapp_enable_bt_stack <pre><code>esp_err_t esp_bluedroid_enable(void) // [tlkapp_enable_bt_stack](Telink.md/#tlkapp_enable_bt_stack)\n{\n    btc_msg_t msg;\n    future_t **future_p;\n\n    if (!bd_already_init) {\n        LOG_ERROR(\"Bludroid not initialised\\n\");\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    if (bd_already_enable) {\n        LOG_ERROR(\"Bluedroid already enabled\\n\");\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    future_p = btc_main_get_future_p(BTC_MAIN_ENABLE_FUTURE);\n    *future_p = future_new();\n    if (*future_p == NULL) {\n        LOG_ERROR(\"Bluedroid enable failed\\n\");\n        return ESP_ERR_NO_MEM;\n    }\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_MAIN_INIT;\n    msg.act = BTC_MAIN_ACT_ENABLE;\n\n    if (btc_transfer_context(&amp;msg, NULL, 0, NULL, NULL) != BT_STATUS_SUCCESS) {\n        LOG_ERROR(\"Bluedroid enable failed\\n\");\n        return ESP_FAIL;\n    }\n\n    if (future_await(*future_p) == FUTURE_FAIL) {\n        LOG_ERROR(\"Bluedroid enable failed\\n\");\n        return ESP_FAIL;\n    }\n\n    bd_already_enable = true;\n\n    return ESP_OK;\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_ble_gap_register_callback","title":"esp_ble_gap_register_callback","text":"<pre><code>esp_err_t esp_ble_gap_register_callback(esp_gap_ble_cb_t callback)\n{\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    return (btc_profile_cb_set(BTC_PID_GAP_BLE, callback) == 0 ? ESP_OK : ESP_FAIL);\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gattc_register_callback","title":"esp_ble_gattc_register_callback","text":"<pre><code>esp_err_t esp_ble_gattc_register_callback(esp_gattc_cb_t callback)\n{\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    if (callback == NULL) {\n        return ESP_FAIL;\n    }\n\n    btc_profile_cb_set(BTC_PID_GATTC, callback);\n    return ESP_OK;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gap_set_device_name","title":"esp_ble_gap_set_device_name","text":"<p>blc_svc_setDeviceName <pre><code>esp_err_t esp_ble_gap_set_device_name(const char *name) //[blc_svc_setDeviceName](Telink.md/#blc_svc_setdevicename)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gap_args_t arg;\n\n    if (esp_bluedroid_get_status() != ESP_BLUEDROID_STATUS_ENABLED) {\n        return ESP_ERR_INVALID_STATE;\n    }\n    if (!name){\n        return ESP_ERR_INVALID_ARG;\n    }\n    if (strlen(name) &gt; BTC_MAX_LOC_BD_NAME_LEN) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GAP_BLE;\n    msg.act = BTC_GAP_BLE_ACT_SET_DEV_NAME;\n    arg.set_dev_name.device_name = (char *)name;\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gap_args_t), btc_gap_ble_arg_deep_copy, btc_gap_ble_arg_deep_free) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_ble_gap_set_security_param","title":"esp_ble_gap_set_security_param","text":"<p>smp security <pre><code>esp_err_t esp_ble_gap_set_security_param(esp_ble_sm_param_t param_type,\n        void *value, uint8_t len) //[smp security](Telink.md/#smp-security)\n{\n    if(param_type &gt;= ESP_BLE_SM_MAX_PARAM) {\n        return ESP_ERR_INVALID_ARG;\n    }\n    if((param_type != ESP_BLE_SM_CLEAR_STATIC_PASSKEY) &amp;&amp; ( value == NULL || len &lt; sizeof(uint8_t) || len &gt; sizeof(uint32_t))) {\n        return ESP_ERR_INVALID_ARG;\n    }\n    if(param_type == ESP_BLE_SM_SET_STATIC_PASSKEY) {\n        uint32_t passkey = 0;\n        for(uint8_t i = 0; i &lt; len; i++)\n        {\n            passkey += (((uint8_t *)value)[i]&lt;&lt;(8*i));\n        }\n        if(passkey &gt; 999999) {\n            return ESP_ERR_INVALID_ARG;\n        }\n    }\n    if (param_type == ESP_BLE_APP_ENC_KEY_SIZE) {\n        LOG_ERROR(\"ESP_BLE_APP_ENC_KEY_SIZE is deprecated, use ESP_GATT_PERM_ENCRYPT_KEY_SIZE in characteristic definition\");\n        return ESP_ERR_NOT_SUPPORTED;\n    }\n    if (param_type == ESP_BLE_SM_MAX_KEY_SIZE || param_type == ESP_BLE_SM_MIN_KEY_SIZE) {\n        if (((uint8_t *)value)[0] &gt; 16 || ((uint8_t *)value)[0] &lt; 7) {\n            return ESP_ERR_INVALID_ARG;\n        }\n    }\n    btc_msg_t msg = {0};\n    btc_ble_gap_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GAP_BLE;\n    msg.act = BTC_GAP_BLE_SET_SECURITY_PARAM_EVT;\n    arg.set_security_param.param_type = param_type;\n    arg.set_security_param.len = len;\n    arg.set_security_param.value = value;\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gap_args_t), btc_gap_ble_arg_deep_copy,\n                btc_gap_ble_arg_deep_free) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_bt_controller_get_status","title":"esp_bt_controller_get_status","text":"<p>btdm_controller_status <pre><code>esp_bt_controller_status_t esp_bt_controller_get_status(void)\n{\n    return btdm_controller_status; //[btdm_controller_status](ESP-IDF.md/#btdm_controller_status)\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#btdm_controller_status","title":"btdm_controller_status","text":"<pre><code>static DRAM_ATTR esp_bt_controller_status_t btdm_controller_status = ESP_BT_CONTROLLER_STATUS_IDLE;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_err_to_name","title":"esp_err_to_name","text":"<pre><code>const char *esp_err_to_name(esp_err_t code)\n{\n#ifdef CONFIG_ESP_ERR_TO_NAME_LOOKUP\n    size_t i;\n\n    for (i = 0; i &lt; sizeof(esp_err_msg_table) / sizeof(esp_err_msg_table[0]); ++i) {\n        if (esp_err_msg_table[i].code == code) {\n            return esp_err_msg_table[i].msg;\n        }\n    }\n#endif //CONFIG_ESP_ERR_TO_NAME_LOOKUP\n\n    return esp_unknown_msg;\n}\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_app_register","title":"esp_ble_gatts_app_register","text":"<p>Register Server App <pre><code>esp_err_t esp_ble_gatts_app_register(uint16_t app_id) //[Register Server App](Telink.md/#register-server-app)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    //if (app_id &lt; ESP_APP_ID_MIN || app_id &gt; ESP_APP_ID_MAX) {\n    if (app_id &gt; ESP_APP_ID_MAX) {\n        return ESP_ERR_INVALID_ARG;\n    }\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_APP_REGISTER;\n    arg.app_reg.app_id = app_id;\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), NULL, NULL) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_create_service","title":"esp_ble_gatts_create_service","text":"<p>Create Service <pre><code>esp_err_t esp_ble_gatts_create_service(esp_gatt_if_t gatts_if,\n                                       esp_gatt_srvc_id_t *service_id, uint16_t num_handle) //[Create Service](Telink.md/#create-service)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_CREATE_SERVICE;\n    arg.create_srvc.gatts_if = gatts_if;\n    arg.create_srvc.num_handle = num_handle;\n    memcpy(&amp;arg.create_srvc.service_id, service_id, sizeof(esp_gatt_srvc_id_t));\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), NULL, NULL) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_gatt_char_prop_t","title":"esp_gatt_char_prop_t","text":"<pre><code>typedef uint8_t esp_gatt_char_prop_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_attr_value_t","title":"esp_attr_value_t","text":"<pre><code>typedef struct\n{\n    uint16_t attr_max_len;                                  /* linked  attribute max value length */\n    uint16_t attr_len;                                      /* linked  attribute current value length */\n    uint8_t  *attr_value;                                   /* linked  the pointer to attribute value */\n} esp_attr_value_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_set_attr_value","title":"esp_ble_gatts_set_attr_value","text":"<p>Attribute Values <pre><code>esp_err_t esp_ble_gatts_set_attr_value(uint16_t attr_handle, uint16_t length, const uint8_t *value) //[Attribute Values](Telink.md/#attribute-values)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_SET_ATTR_VALUE;\n    arg.set_attr_val.handle = attr_handle;\n    arg.set_attr_val.length = length;\n    arg.set_attr_val.value  = (uint8_t *)value;\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), btc_gatts_arg_deep_copy,\n                btc_gatts_arg_deep_free) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_start_service","title":"esp_ble_gatts_start_service","text":"<p>GATT Start Service <pre><code>esp_err_t esp_ble_gatts_start_service(uint16_t service_handle) //[GATT Start Service](Telink.md/#gatt-start-service)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_START_SERVICE;\n    arg.start_srvc.service_handle = service_handle;\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), NULL, NULL) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_attr_control_t","title":"esp_attr_control_t","text":"<pre><code>typedef struct\n{\n    /**\n     * @brief Controls who handles the response to Read/Write operations.\n     *\n     * - If set to @c ESP_GATT_RSP_BY_APP, the application is responsible for\n     *   generating the response.\n     * - If set to @c ESP_GATT_AUTO_RSP, the GATT stack will automatically generate\n     *   the response.\n     */\n    uint8_t auto_rsp;\n} esp_attr_control_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_gatt_perm_t","title":"esp_gatt_perm_t","text":"<pre><code>typedef uint16_t esp_gatt_perm_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_add_char_descr","title":"esp_ble_gatts_add_char_descr","text":"<p>Add Characteristic <pre><code>esp_err_t esp_ble_gatts_add_char_descr (uint16_t service_handle,\n                                        esp_bt_uuid_t   *descr_uuid,\n                                        esp_gatt_perm_t perm, esp_attr_value_t *char_descr_val,\n                                        esp_attr_control_t *control) //[Add Characteristic](Telink.md/#add-characteristic)\n{\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n    esp_err_t status;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    /* parameter validation check */\n    status = esp_ble_gatts_add_char_desc_param_check(char_descr_val, control);\n    if (status != ESP_OK){\n        return status;\n    }\n\n    memset(&amp;arg, 0, sizeof(btc_ble_gatts_args_t));\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_ADD_CHAR_DESCR;\n    arg.add_descr.service_handle = service_handle;\n    arg.add_descr.perm = perm;\n\n    if (char_descr_val != NULL) {\n        arg.add_descr.descr_val.attr_max_len = char_descr_val-&gt;attr_max_len;\n        arg.add_descr.descr_val.attr_len = char_descr_val-&gt;attr_len;\n        arg.add_descr.descr_val.attr_value = char_descr_val-&gt;attr_value;\n    }\n\n    if (control != NULL) {\n        arg.add_descr.attr_control.auto_rsp = control-&gt;auto_rsp;\n    }\n    memcpy(&amp;arg.add_descr.descr_uuid, descr_uuid, sizeof(esp_bt_uuid_t));\n\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), btc_gatts_arg_deep_copy,\n                btc_gatts_arg_deep_free) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_ble_adv_data_type","title":"esp_ble_adv_data_type","text":"<pre><code>typedef enum {\n    ESP_BLE_AD_TYPE_FLAG                     = 0x01,    /* relate to BTM_BLE_AD_TYPE_FLAG in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_16SRV_PART               = 0x02,    /* relate to BTM_BLE_AD_TYPE_16SRV_PART in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_16SRV_CMPL               = 0x03,    /* relate to BTM_BLE_AD_TYPE_16SRV_CMPL in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_32SRV_PART               = 0x04,    /* relate to BTM_BLE_AD_TYPE_32SRV_PART in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_32SRV_CMPL               = 0x05,    /* relate to BTM_BLE_AD_TYPE_32SRV_CMPL in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_128SRV_PART              = 0x06,    /* relate to BTM_BLE_AD_TYPE_128SRV_PART in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_128SRV_CMPL              = 0x07,    /* relate to BTM_BLE_AD_TYPE_128SRV_CMPL in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_NAME_SHORT               = 0x08,    /* relate to BTM_BLE_AD_TYPE_NAME_SHORT in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_NAME_CMPL                = 0x09,    /* relate to BTM_BLE_AD_TYPE_NAME_CMPL in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_TX_PWR                   = 0x0A,    /* relate to BTM_BLE_AD_TYPE_TX_PWR in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_DEV_CLASS                = 0x0D,    /* relate to BTM_BLE_AD_TYPE_DEV_CLASS in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SM_TK                    = 0x10,    /* relate to BTM_BLE_AD_TYPE_SM_TK in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SM_OOB_FLAG              = 0x11,    /* relate to BTM_BLE_AD_TYPE_SM_OOB_FLAG in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_INT_RANGE                = 0x12,    /* relate to BTM_BLE_AD_TYPE_INT_RANGE in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SOL_SRV_UUID             = 0x14,    /* relate to BTM_BLE_AD_TYPE_SOL_SRV_UUID in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_128SOL_SRV_UUID          = 0x15,    /* relate to BTM_BLE_AD_TYPE_128SOL_SRV_UUID in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SERVICE_DATA             = 0x16,    /* relate to BTM_BLE_AD_TYPE_SERVICE_DATA in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_PUBLIC_TARGET            = 0x17,    /* relate to BTM_BLE_AD_TYPE_PUBLIC_TARGET in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_RANDOM_TARGET            = 0x18,    /* relate to BTM_BLE_AD_TYPE_RANDOM_TARGET in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_APPEARANCE               = 0x19,    /* relate to BTM_BLE_AD_TYPE_APPEARANCE in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_ADV_INT                  = 0x1A,    /* relate to BTM_BLE_AD_TYPE_ADV_INT in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_LE_DEV_ADDR              = 0x1b,    /* relate to BTM_BLE_AD_TYPE_LE_DEV_ADDR in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_LE_ROLE                  = 0x1c,    /* relate to BTM_BLE_AD_TYPE_LE_ROLE in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SPAIR_C256               = 0x1d,    /* relate to BTM_BLE_AD_TYPE_SPAIR_C256 in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_SPAIR_R256               = 0x1e,    /* relate to BTM_BLE_AD_TYPE_SPAIR_R256 in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_32SOL_SRV_UUID           = 0x1f,    /* relate to BTM_BLE_AD_TYPE_32SOL_SRV_UUID in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_32SERVICE_DATA           = 0x20,    /* relate to BTM_BLE_AD_TYPE_32SERVICE_DATA in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_128SERVICE_DATA          = 0x21,    /* relate to BTM_BLE_AD_TYPE_128SERVICE_DATA in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_LE_SECURE_CONFIRM        = 0x22,    /* relate to BTM_BLE_AD_TYPE_LE_SECURE_CONFIRM in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_LE_SECURE_RANDOM         = 0x23,    /* relate to BTM_BLE_AD_TYPE_LE_SECURE_RANDOM in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_URI                      = 0x24,    /* relate to BTM_BLE_AD_TYPE_URI in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_INDOOR_POSITION          = 0x25,    /* relate to BTM_BLE_AD_TYPE_INDOOR_POSITION in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_TRANS_DISC_DATA          = 0x26,    /* relate to BTM_BLE_AD_TYPE_TRANS_DISC_DATA in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_LE_SUPPORT_FEATURE       = 0x27,    /* relate to BTM_BLE_AD_TYPE_LE_SUPPORT_FEATURE in stack/btm_ble_api.h */\n    ESP_BLE_AD_TYPE_CHAN_MAP_UPDATE          = 0x28,    /* relate to BTM_BLE_AD_TYPE_CHAN_MAP_UPDATE in stack/btm_ble_api.h */\n    ESP_BLE_AD_MANUFACTURER_SPECIFIC_TYPE    = 0xFF,    /* relate to BTM_BLE_AD_MANUFACTURER_SPECIFIC_TYPE in stack/btm_ble_api.h */\n} esp_ble_adv_data_type;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_adv_params_t","title":"esp_ble_adv_params_t","text":"<pre><code>typedef struct {\n    uint16_t                adv_int_min;        /* linked Minimum advertising interval for\n                                                  undirected and low duty cycle directed advertising.\n                                                  Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second)\n                                                  Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec */\n    uint16_t                adv_int_max;        /* linked Maximum advertising interval for\n                                                  undirected and low duty cycle directed advertising.\n                                                  Range: 0x0020 to 0x4000 Default: N = 0x0800 (1.28 second)\n                                                  Time = N * 0.625 msec Time Range: 20 ms to 10.24 sec Advertising max interval */\n    esp_ble_adv_type_t      adv_type;           /* linked Advertising type */\n    esp_ble_addr_type_t     own_addr_type;      /* linked Owner bluetooth device address type */\n    esp_bd_addr_t           peer_addr;          /* linked Peer device bluetooth device address */\n    esp_ble_addr_type_t     peer_addr_type;     /* linked Peer device bluetooth device address type, only support public address type and random address type */\n    esp_ble_adv_channel_t   channel_map;        /* linked Advertising channel map */\n    esp_ble_adv_filter_t    adv_filter_policy;  /* linked Advertising filter policy */\n} esp_ble_adv_params_t;\n</code></pre>"},{"location":"Libraries/ESP-IDF/#esp_ble_gatts_send_indicate","title":"esp_ble_gatts_send_indicate","text":"<p>GATTS Notify <pre><code>esp_err_t esp_ble_gatts_send_indicate(esp_gatt_if_t gatts_if, uint16_t conn_id, uint16_t attr_handle,\n                                      uint16_t value_len, uint8_t *value, bool need_confirm) //[GATTS Notify](Telink.md/#gatts-notify)\n{\n    if (value_len &gt; ESP_GATT_MAX_ATTR_LEN) {\n        LOG_ERROR(\"%s, value_len &gt; ESP_GATT_MAX_ATTR_LEN.\", __func__);\n        return ESP_ERR_INVALID_SIZE;\n    }\n\n    btc_msg_t msg = {0};\n    btc_ble_gatts_args_t arg;\n\n    ESP_BLUEDROID_STATUS_CHECK(ESP_BLUEDROID_STATUS_ENABLED);\n\n    tGATT_TCB       *p_tcb = gatt_get_tcb_by_idx(conn_id);\n    if (!gatt_check_connection_state_by_tcb(p_tcb)) {\n        LOG_WARN(\"%s, The connection not created.\", __func__);\n        return ESP_ERR_INVALID_STATE;\n    }\n\n    if (L2CA_CheckIsCongest(L2CAP_ATT_CID, p_tcb-&gt;peer_bda)) {\n        LOG_DEBUG(\"%s, the l2cap channel is congest.\", __func__);\n        return ESP_FAIL;\n    }\n\n    msg.sig = BTC_SIG_API_CALL;\n    msg.pid = BTC_PID_GATTS;\n    msg.act = BTC_GATTS_ACT_SEND_INDICATE;\n    arg.send_ind.conn_id = BTC_GATT_CREATE_CONN_ID(gatts_if, conn_id);\n    arg.send_ind.attr_handle = attr_handle;\n    arg.send_ind.need_confirm = need_confirm;\n    arg.send_ind.value_len = value_len;\n    arg.send_ind.value = value;\n    if(need_confirm == false){\n        l2ble_update_att_acl_pkt_num(L2CA_ADD_BTC_NUM, NULL);\n    }\n    return (btc_transfer_context(&amp;msg, &amp;arg, sizeof(btc_ble_gatts_args_t), btc_gatts_arg_deep_copy,\n                btc_gatts_arg_deep_free) == BT_STATUS_SUCCESS ? ESP_OK : ESP_FAIL);\n}\n</code></pre></p>"},{"location":"Libraries/ESP-IDF/#esp_gatt_status_t","title":"esp_gatt_status_t","text":"<p>```c typedef enum {     ESP_GATT_OK                     =   0x0,    / linked 0x0, Operation successful. Corresponds to BTA_GATT_OK. /     ESP_GATT_INVALID_HANDLE         =   0x01,   / linked 0x01, Invalid handle. Corresponds to BTA_GATT_INVALID_HANDLE. /     ESP_GATT_READ_NOT_PERMIT        =   0x02,   / linked 0x02, Read operation not permitted. Corresponds to BTA_GATT_READ_NOT_PERMIT. /     ESP_GATT_WRITE_NOT_PERMIT       =   0x03,   / linked 0x03, Write operation not permitted. Corresponds to BTA_GATT_WRITE_NOT_PERMIT. /     ESP_GATT_INVALID_PDU            =   0x04,   / linked 0x04, Invalid PDU. Corresponds to BTA_GATT_INVALID_PDU. /     ESP_GATT_INSUF_AUTHENTICATION   =   0x05,   / linked 0x05, Insufficient authentication. Corresponds to BTA_GATT_INSUF_AUTHENTICATION. /     ESP_GATT_REQ_NOT_SUPPORTED      =   0x06,   / linked 0x06, Request not supported. Corresponds to BTA_GATT_REQ_NOT_SUPPORTED. /     ESP_GATT_INVALID_OFFSET         =   0x07,   / linked 0x07, Invalid offset. Corresponds to BTA_GATT_INVALID_OFFSET. /     ESP_GATT_INSUF_AUTHORIZATION    =   0x08,   / linked 0x08, Insufficient authorization. Corresponds to BTA_GATT_INSUF_AUTHORIZATION. /     ESP_GATT_PREPARE_Q_FULL         =   0x09,   / linked 0x09, Prepare queue full. Corresponds to BTA_GATT_PREPARE_Q_FULL. /     ESP_GATT_NOT_FOUND              =   0x0a,   / linked 0x0a, Not found. Corresponds to BTA_GATT_NOT_FOUND. /     ESP_GATT_NOT_LONG               =   0x0b,   / linked 0x0b, Not long. Corresponds to BTA_GATT_NOT_LONG. /     ESP_GATT_INSUF_KEY_SIZE         =   0x0c,   / linked 0x0c, Insufficient key size. Corresponds to BTA_GATT_INSUF_KEY_SIZE. /     ESP_GATT_INVALID_ATTR_LEN       =   0x0d,   / linked 0x0d, Invalid attribute length. Corresponds to BTA_GATT_INVALID_ATTR_LEN. /     ESP_GATT_ERR_UNLIKELY           =   0x0e,   / linked 0x0e, Unlikely error. Corresponds to BTA_GATT_ERR_UNLIKELY. /     ESP_GATT_INSUF_ENCRYPTION       =   0x0f,   / linked 0x0f, Insufficient encryption. Corresponds to BTA_GATT_INSUF_ENCRYPTION. /     ESP_GATT_UNSUPPORT_GRP_TYPE     =   0x10,   / linked 0x10, Unsupported group type. Corresponds to BTA_GATT_UNSUPPORT_GRP_TYPE. /     ESP_GATT_INSUF_RESOURCE         =   0x11,   / linked 0x11, Insufficient resource. Corresponds to BTA_GATT_INSUF_RESOURCE. /</p> <pre><code>/* Additional error codes specific to implementation or future use */\nESP_GATT_NO_RESOURCES           =   0x80,   /* linked 0x80, No resources. Corresponds to BTA_GATT_NO_RESOURCES. */\nESP_GATT_INTERNAL_ERROR         =   0x81,   /* linked 0x81, Internal error. Corresponds to BTA_GATT_INTERNAL_ERROR. */\nESP_GATT_WRONG_STATE            =   0x82,   /* linked 0x82, Wrong state. Corresponds to BTA_GATT_WRONG_STATE. */\nESP_GATT_DB_FULL                =   0x83,   /* linked 0x83, Database full. Corresponds to BTA_GATT_DB_FULL. */\nESP_GATT_BUSY                   =   0x84,   /* linked 0x84, Busy. Corresponds to BTA_GATT_BUSY. */\nESP_GATT_ERROR                  =   0x85,   /* linked 0x85, Generic error. Corresponds to BTA_GATT_ERROR. */\nESP_GATT_CMD_STARTED            =   0x86,   /* linked 0x86, Command started. Corresponds to BTA_GATT_CMD_STARTED. */\nESP_GATT_ILLEGAL_PARAMETER      =   0x87,   /* linked 0x87, Illegal parameter. Corresponds to BTA_GATT_ILLEGAL_PARAMETER. */\nESP_GATT_PENDING                =   0x88,   /* linked 0x88, Operation pending. Corresponds to BTA_GATT_PENDING. */\nESP_GATT_AUTH_FAIL              =   0x89,   /* linked 0x89, Authentication failed. Corresponds to BTA_GATT_AUTH_FAIL. */\nESP_GATT_MORE                   =   0x8a,   /* linked 0x8a, More data available. Corresponds to BTA_GATT_MORE. */\nESP_GATT_INVALID_CFG            =   0x8b,   /* linked 0x8b, Invalid configuration. Corresponds to BTA_GATT_INVALID_CFG. */\nESP_GATT_SERVICE_STARTED        =   0x8c,   /* linked 0x8c, Service started. Corresponds to BTA_GATT_SERVICE_STARTED. */\nESP_GATT_ENCRYPTED_MITM         =   ESP_GATT_OK, /* linked 0x0, Encrypted, with MITM protection. Corresponds to BTA_GATT_ENCRYPTED_MITM. */\nESP_GATT_ENCRYPTED_NO_MITM      =   0x8d,   /* linked 0x8d, Encrypted, without MITM protection. Corresponds to BTA_GATT_ENCRYPTED_NO_MITM. */\nESP_GATT_NOT_ENCRYPTED          =   0x8e,   /* linked 0x8e, Not encrypted. Corresponds to BTA_GATT_NOT_ENCRYPTED. */\nESP_GATT_CONGESTED              =   0x8f,   /* linked 0x8f, Congested. Corresponds to BTA_GATT_CONGESTED. */\nESP_GATT_DUP_REG                =   0x90,   /* linked 0x90, Duplicate registration. Corresponds to BTA_GATT_DUP_REG. */\nESP_GATT_ALREADY_OPEN           =   0x91,   /* linked 0x91, Already open. Corresponds to BTA_GATT_ALREADY_OPEN. */\nESP_GATT_CANCEL                 =   0x92,   /* linked 0x92, Operation cancelled. Corresponds to BTA_GATT_CANCEL. */\n/* 0xE0 ~ 0xFC reserved for future use */\nESP_GATT_STACK_RSP              =   0xe0,   /* linked 0xe0, Stack response. Corresponds to BTA_GATT_STACK_RSP. */\nESP_GATT_APP_RSP                =   0xe1,   /* linked 0xe1, Application response. Corresponds to BTA_GATT_APP_RSP. */\n/* Error caused by customer application or stack bug */\nESP_GATT_UNKNOWN_ERROR          =   0xef,   /* linked 0xef, Unknown error. Corresponds to BTA_GATT_UNKNOWN_ERROR. */\nESP_GATT_CCC_CFG_ERR            =   0xfd,   /* linked 0xfd, Client Characteristic Configuration Descriptor improperly configured. Corresponds to BTA_GATT_CCC_CFG_ERR. */\nESP_GATT_PRC_IN_PROGRESS        =   0xfe,   /* linked 0xfe, Procedure already in progress. Corresponds to BTA_GATT_PRC_IN_PROGRESS. */\nESP_GATT_OUT_OF_RANGE           =   0xff    /* linked 0xff, Attribute value out of range. Corresponds to BTA_GATT_OUT_OF_RANGE. */\n</code></pre> <p>} esp_gatt_status_t;</p>"},{"location":"Libraries/Telink/","title":"Telink","text":"<p>test</p>"},{"location":"Libraries/Telink/#1-architecture-design-philosophy","title":"1. Architecture &amp; Design Philosophy","text":""},{"location":"Libraries/Telink/#esp32-bluedroid","title":"ESP32 (Bluedroid)","text":"<ul> <li>Monolithic Design: Single integrated stack with tight coupling</li> <li>Centralized Control: One main Bluetooth task controller (<code>btc_init</code>)</li> <li>Dynamic Configuration: Runtime configuration through structures</li> <li>High-Level APIs: Focus on ease of use with abstracted interfaces</li> </ul>"},{"location":"Libraries/Telink/#telink-sdk","title":"Telink SDK","text":"<ul> <li>Layered Architecture: Modular design with clear separation of concerns</li> <li>Distributed Control: Multiple independent layers (tlkapp, stack/ble, tlkapi, drivers)</li> <li>Compile-time Configuration: Uses <code>#define</code> macros for configuration</li> <li>Low-Level Control: Direct hardware access and fine-grained control</li> </ul>"},{"location":"Libraries/Telink/#2-stack-organization","title":"2. Stack Organization","text":""},{"location":"Libraries/Telink/#esp32-stack-layers","title":"ESP32 Stack Layers","text":"<pre><code>Application Layer (Arduino BLE Library)\n         \u2193\nESP-IDF Bluetooth API (Bluedroid)\n         \u2193\nController Layer (ESP32 Hardware)\n</code></pre>"},{"location":"Libraries/Telink/#telink-stack-layers","title":"Telink Stack Layers","text":"<pre><code>tlkapp (Application Layer)\n         \u2193\nstack/ble (Protocol Stack)\n         \u2193\ntlkapi (API Layer)\n         \u2193\ndrivers (Hardware Layer)\n</code></pre>"},{"location":"Libraries/Telink/#3-memory-management","title":"3. Memory Management","text":""},{"location":"Libraries/Telink/#esp32","title":"ESP32","text":"<ul> <li>Dynamic Allocation: Uses <code>osi_malloc()</code>, <code>osi_calloc()</code> for runtime memory</li> <li>Future System: Uses futures for asynchronous operation synchronization</li> <li>Centralized Memory: Single memory pool managed by the stack</li> </ul>"},{"location":"Libraries/Telink/#telink","title":"Telink","text":"<ul> <li>Static Allocation: Pre-allocated memory pools and buffers</li> <li>Event-Based: Uses event tables and semaphores for synchronization</li> <li>Distributed Memory: Each layer manages its own memory</li> </ul>"},{"location":"Libraries/Telink/#4-task-management","title":"4. Task Management","text":""},{"location":"Libraries/Telink/#esp32_1","title":"ESP32","text":"<ul> <li>Single Bluetooth Task: <code>btc_thread</code> handles all Bluetooth operations</li> <li>Work Queue System: Uses work queues for message processing</li> <li>Centralized Scheduling: All Bluetooth operations go through one task</li> </ul>"},{"location":"Libraries/Telink/#telink_1","title":"Telink","text":"<ul> <li>Multiple Tasks: Separate tasks for different functions (<code>tlksys_task_create</code>)</li> <li>Message Queue System: Individual message queues per task</li> <li>Distributed Scheduling: Each layer can have its own task</li> </ul>"},{"location":"Libraries/Telink/#5-configuration-approach","title":"5. Configuration Approach","text":""},{"location":"Libraries/Telink/#esp32_2","title":"ESP32","text":"<pre><code>esp_bluedroid_config_t cfg = {\n    .mode = ESP_BT_MODE_BLE,\n    .controller_task_stack_size = 4096,\n    .controller_task_prio = 5,\n    .sc_en = true,\n    .ssp_en = true\n};\nesp_bluedroid_init_with_cfg(&amp;cfg);\n</code></pre>"},{"location":"Libraries/Telink/#telink_2","title":"Telink","text":"<pre><code>// Compile-time configuration\n#define TLK_STK_BT_ENABLE          1\n#define BLE_MAX_CONNECTION         4\n#define GATT_MTU_SIZE             23\n#define BLE_SECURITY_ENABLE        1\n</code></pre>"},{"location":"Libraries/Telink/#6-gatt-database-management","title":"6. GATT Database Management","text":""},{"location":"Libraries/Telink/#esp32_3","title":"ESP32","text":"<ul> <li>Dynamic Creation: Services and characteristics created at runtime</li> <li>Object-Oriented: Uses C++ classes for GATT elements</li> <li>Automatic Management: Stack handles database organization</li> </ul>"},{"location":"Libraries/Telink/#telink_3","title":"Telink","text":"<ul> <li>Static Definition: GATT database defined at compile time</li> <li>Structure-Based: Uses C structures for GATT elements</li> <li>Manual Management: Developer must define complete database structure</li> </ul>"},{"location":"Libraries/Telink/#7-event-handling","title":"7. Event Handling","text":""},{"location":"Libraries/Telink/#esp32_4","title":"ESP32","text":"<pre><code>esp_ble_gap_register_callback(gap_event_handler);\nesp_ble_gatts_register_callback(gatts_event_handler);\n</code></pre>"},{"location":"Libraries/Telink/#telink_4","title":"Telink","text":"<pre><code>blc_gap_register_event_callback(gap_event_handler);\nblc_gatt_register_server_callback(gatts_event_handler);\n</code></pre>"},{"location":"Libraries/Telink/#8-transport-layer","title":"8. Transport Layer","text":""},{"location":"Libraries/Telink/#esp32_5","title":"ESP32","text":"<ul> <li>HCI over UART/SPI: Standard HCI transport</li> <li>Internal Communication: Direct function calls within SoC</li> </ul>"},{"location":"Libraries/Telink/#telink_5","title":"Telink","text":"<ul> <li>H0TL (Host-0-Transport-Layer): Custom transport for SoC mode</li> <li>FIFO-based Communication: Uses FIFOs for host-controller communication</li> </ul>"},{"location":"Libraries/Telink/#9-security-features","title":"9. Security Features","text":""},{"location":"Libraries/Telink/#esp32_6","title":"ESP32","text":"<ul> <li>Runtime Security Configuration: Secure Connections, Simple Secure Pairing</li> <li>Dynamic Key Management: Runtime encryption key generation</li> </ul>"},{"location":"Libraries/Telink/#telink_6","title":"Telink","text":"<ul> <li>Compile-time Security: Security features configured at build time</li> <li>Static Key Storage: Keys stored in flash/OTP areas</li> </ul>"},{"location":"Libraries/Telink/#10-development-approach","title":"10. Development Approach","text":""},{"location":"Libraries/Telink/#esp32_7","title":"ESP32","text":"<ul> <li>High-Level Development: Focus on rapid prototyping</li> <li>Arduino Compatibility: Easy migration from Arduino BLE library</li> <li>Automatic Optimization: Stack handles performance optimization</li> </ul>"},{"location":"Libraries/Telink/#telink_7","title":"Telink","text":"<ul> <li>Low-Level Development: Focus on performance and control</li> <li>Hardware-Specific: Optimized for Telink chips</li> <li>Manual Optimization: Developer controls performance aspects</li> </ul>"},{"location":"Libraries/Telink/#summary","title":"Summary","text":"<p>The ESP32 stack prioritizes ease of use and rapid development, while the Telink stack prioritizes performance, control, and hardware optimization. ESP32 is better for quick prototyping and Arduino-style development, while Telink is better for production systems requiring fine-grained control and optimization.</p> <pre><code>Application Layer (Arduino BLE Library)\n         \u2193\nESP-IDF Bluetooth API (Bluedroid)\n         \u2193\nController Layer (ESP32 Hardware)\n</code></pre> <pre><code>tlkapp (Application Layer)\n         \u2193\nstack/ble (Protocol Stack)\n         \u2193\ntlkapi (API Layer)\n         \u2193\ndrivers (Hardware Layer)\n</code></pre> <pre><code>esp_bluedroid_config_t cfg = {\n    .mode = ESP_BT_MODE_BLE,\n    .controller_task_stack_size = 4096,\n    .controller_task_prio = 5,\n    .sc_en = true,\n    .ssp_en = true\n};\nesp_bluedroid_init_with_cfg(&amp;cfg);\n</code></pre> <pre><code>// Compile-time configuration\n#define TLK_STK_BT_ENABLE          1\n#define BLE_MAX_CONNECTION         4\n#define GATT_MTU_SIZE             23\n#define BLE_SECURITY_ENABLE        1\n</code></pre> <pre><code>esp_ble_gap_register_callback(gap_event_handler);\nesp_ble_gatts_register_callback(gatts_event_handler);\n</code></pre> <pre><code>blc_gap_register_event_callback(gap_event_handler);\nblc_gatt_register_server_callback(gatts_event_handler);\n</code></pre>"},{"location":"Libraries/Telink/#nvs-non-volatile-storage","title":"nvs (non-volatile storage)","text":"<p><pre><code>#ifdef ARDUINO_ARCH_ESP32\n    if (!btStart()) { //[[Arduino BLE Libraries#btStart()|btStart()]]\n      errRc = ESP_FAIL; //[[ESP-IDF#esp_err_t|esp_err_t]] errRc; #define ESP_FAIL        -1\n      return;\n    }\n#else\n    errRc = ::nvs_flash_init(); //[[ESP-IDF#nvs_flash_init|nvs_flash-init]]\n    if (errRc != ESP_OK) { //#define ESP_OK 0\n      log_e(\"nvs_flash_init: rc=%d %s\", errRc, GeneralUtils::errorToString(errRc));\n      return;\n    }\n</code></pre> Espressif has branded their flash storage as \"NVS\" Bluetooth needs flash memory for pairing information etc.</p> <p>creates a partition</p>"},{"location":"Libraries/Telink/#memory-allocation","title":"Memory Allocation","text":"<ol> <li> <p>Different Architecture: Telink uses static\u00a0memory\u00a0allocation vs ESP32's dynamic\u00a0approach</p> </li> <li> <p>Memory Model: Telink reserves memory permanently for Bluetooth operations</p> </li> <li> <p>Resource Management: No need to\u00a0release memory since it's\u00a0always allocated</p> </li> </ol> <p>The Telink SDK doesn't have a memory release function because it uses a different memory\u00a0management strategy.</p>"},{"location":"Libraries/Telink/#controller-init","title":"Controller Init","text":"<pre><code>void controller_init(controller_mode mode, HCI_TR_MODE tr_mode, HCI_TR_UART *hci_tr_uart, \u00a0void *parameter);\n</code></pre>"},{"location":"Libraries/Telink/#controller-enable","title":"Controller Enable","text":"<p>Telink combines initialization and enable into a single step While Telink doesn't have\u00a0a direct\u00a0disable()\u00a0function, it\u00a0does have:</p> <ul> <li> <p>Power\u00a0management functions\u00a0(rwip_sleep(),\u00a0pm_set_dig_module_power_switch())</p> </li> <li> <p>Deinitialization patterns\u00a0in some applications</p> </li> <li> <p>Resource\u00a0cleanup\u00a0mechanisms</p> </li> </ul>"},{"location":"Libraries/Telink/#bluetooth-stack-init","title":"Bluetooth stack init","text":"<pre><code>void tlkstk_init(void)\n\n{\n\n#if (TLK_STK_BT_ENABLE)\n\n\u00a0 \u00a0 tlkstk_mem_init();\n\n\u00a0 \u00a0 bth_init();\n\n\u00a0 \u00a0 btp_init();\n\n#endif\n\n}\n</code></pre>"},{"location":"Libraries/Telink/#bluetooth-stack-configs","title":"Bluetooth stack configs","text":"<ul> <li>Compile-time Configuration: Uses\u00a0#define\u00a0macros instead of\u00a0runtime config</li> </ul>"},{"location":"Libraries/Telink/#task-controller","title":"Task Controller","text":"<pre><code>int tlksys_task_create(uint08 taskID, const tlksys_task_cfg_t *pCfgs)\n\n{\n\n\u00a0 \u00a0 if (pCfgs == nullptr || taskID &gt;= TLKSYS_TASKID_MAXNUM) {\n\n\u00a0 \u00a0 \u00a0 \u00a0 return -TLK_EPARAM;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 tlksys_task_t *pTask = &amp;sTlkSysTaskList[taskID];\n\n\u00a0 \u00a0 if(pTask-&gt;adapt.usage != TLKAPI_ADAPT_USAGE_NOMARL){\n\n\u00a0 \u00a0 \u00a0 \u00a0 return -TLK_EREPEAT;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 pTask-&gt;pCfgs = (tlksys_task_cfg_t *)pCfgs;\n\n\u00a0 \u00a0 if (pCfgs-&gt;Init != nullptr &amp;&amp; pCfgs-&gt;Init() != TLK_ENONE) {\n\n\u00a0 \u00a0 \u00a0 \u00a0 return -TLK_EINIT;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 pTask-&gt;adapt.usage = TLKAPI_ADAPT_USAGE_FOR_MAIN_THREAD;\n\n\u00a0 \u00a0 tlkos_event_createTab(16,&amp;sTlkTaskEvtTabHandles[taskID]);\n\n\u00a0 \u00a0 tlkos_msgq_create(&amp;sTlkTaskMsgQHandles[taskID],128,16);\n\n\u00a0 \u00a0 tlkos_event_regDealCB(sTlkTaskEvtTabHandles[taskID],0,tlksys_task_handleWakeUp);\n\n\u00a0 \u00a0 pTask-&gt;adapt.taskID = taskID;\n\n\u00a0 \u00a0 if(pCfgs-&gt;isUseNewThread == 0){\n\n\u00a0 \u00a0 \u00a0 \u00a0 return TLK_ENONE;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 //following code: create new thread\n\n\u00a0 \u00a0 pTask-&gt;adapt.usage = TLKAPI_ADAPT_USAGE_FOR_INDEPENDENCE_THREAD;\n\n\u00a0 \u00a0 int ret = tlkos_task_create(tlksys_template_task,pCfgs-&gt;pTaskName,pCfgs-&gt;stackSize,pCfgs-&gt;priority,pTask,nullptr,&amp;pTask-&gt;taskHandle);\n\n\u00a0 \u00a0 if(ret != TLK_ENONE){\n\n\u00a0 \u00a0 \u00a0 \u00a0 pTask-&gt;adapt.usage = TLKAPI_ADAPT_USAGE_FOR_MAIN_THREAD;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 return TLK_ENONE;\n\n}\n\nvoid tlkstk_init(void)\n{\n#if (TLK_STK_BT_ENABLE)\n    tlkstk_mem_init();\n    bth_init();\n    btp_init();\n#endif\n}\n\nint tlkmdi_bt_init(void)\n{\n    tlkmdi_btadapt_init(TLKSYS_TASKID_BTMGR);\n\n    #if (TLK_STK_BT_ENABLE)\n    tlkmdi_btacl_init();           // ACL connection management\n    tlkmdi_btScan_process_init();  // Scan process initialization\n    #endif\n\n    #if (TLK_MW_BTINQ_ENABLE)\n    tlkmdi_btinq_init();           // Inquiry functionality\n    #endif\n\n    #if (TLKBTP_CFG_ATTSRV_ENABLE)\n    tlkmdi_btatt_init();           // ATT server\n    #endif\n\n    #if (TLKBTP_CFG_HID_ENABLE)\n    tlkmdi_bthid_init();           // HID profile\n    #endif\n\n    #if (TLKBTP_CFG_HFP_ENABLE)\n    tlkmdi_bthfp_init();           // HFP profile\n    #endif\n\n    #if (TLKBTP_CFG_A2DP_ENABLE)\n    tlkmdi_bta2dp_init();          // A2DP profile\n    #endif\n\n    #if (TLKBTP_CFG_HFP_ENABLE)\n    tlkmdi_btsco_init();           // SCO connection\n    #endif\n\n    tlkmdi_bt_mgr_ctrlInit();      // Manager control initialization\n\n    #if (TLKBTP_CFG_PBAP_ENABLE)\n    tlkmdi_pbap_init();            // PBAP profile\n    #endif\n\n    #if (TLKBTP_CFG_IAP_ENABLE)\n    tlkmdi_btiap_init();           // IAP profile\n    #endif\n\n    tlkmdi_bt_sppTestInit();       // SPP test initialization\n    return TLK_ENONE;\n}\n</code></pre>"},{"location":"Libraries/Telink/#future-pointer","title":"Future pointer","text":"<ul> <li> <p>Purpose: Returns a pointer to a specific future object from an array</p> </li> <li> <p>Architecture: Uses futures for asynchronous operation synchronization</p> </li> <li> <p>Use\u00a0Case: Coordinates between\u00a0different\u00a0Bluetooth\u00a0tasks\u00a0and operations</p> </li> </ul> <p>Telink\u00a0SDK Approach:</p> <ul> <li> <p>No\u00a0Future System: Telink doesn't\u00a0use futures for\u00a0task\u00a0synchronization</p> </li> <li> <p>Event-Based: Uses event tables and\u00a0semaphores for task coordination</p> </li> <li> <p>Direct Communication: Tasks\u00a0communicate directly through message\u00a0queues and\u00a0events</p> </li> </ul>"},{"location":"Libraries/Telink/#tlkos_semphr_createbinary","title":"tlkos_semphr_createBinary","text":"<pre><code>int tlkos_semphr_createBinary(TlkOsSemphrHandle_t *semphrHandle)\n{\n    if (semphrHandle == nullptr) {\n        return -TLK_EPARAM;\n    }\n    *semphrHandle = xSemaphoreCreateBinary();\n    return TLK_ENONE;\n}\n</code></pre>"},{"location":"Libraries/Telink/#tlksys_task_input","title":"tlksys_task_input","text":"<pre><code>int tlksys_task_input(uint16 taskID, uint16 msgID, uint08 *pData, uint16 dataLen)\n\n{\n\n\u00a0 \u00a0 if (taskID &gt;= TLKSYS_TASKID_MAXNUM || sTlkSysTaskList[taskID].adapt.usage == 0) {\n\n\u00a0 \u00a0 \u00a0 \u00a0 return -TLK_EPARAM;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 if (sTlkSysTaskList[taskID].pCfgs-&gt;Input == nullptr) {\n\n\u00a0 \u00a0 \u00a0 \u00a0 return -TLK_ENOSUPPORT;\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 if(sTlkSysTaskList[taskID].adapt.usage != TLKAPI_ADAPT_USAGE_FOR_INDEPENDENCE_THREAD){\n\n\u00a0 \u00a0 \u00a0 \u00a0 return sTlkSysTaskList[taskID].pCfgs-&gt;Input(msgID, pData, dataLen);\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 if(tlkos_task_getRunningTask() == sTlkSysTaskList[taskID].taskHandle){\n\n\u00a0 \u00a0 \u00a0 \u00a0 return sTlkSysTaskList[taskID].pCfgs-&gt;Input(msgID, pData, dataLen);\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 //to other thread:\n\n\u00a0 \u00a0 uint08 buffer[dataLen + 4];\n\n\u00a0 \u00a0 buffer[0] = (msgID &amp; 0xFF);\n\n\u00a0 \u00a0 buffer[1] = (msgID &amp; 0xFF00) &gt;&gt; 8;\n\n\u00a0 \u00a0 buffer[2] = (dataLen &amp; 0xFF);\n\n\u00a0 \u00a0 buffer[3] = (dataLen &amp; 0xFF00) &gt;&gt; 8;\n\n\u00a0 \u00a0 tmemcpy(buffer + 4,pData,dataLen);\n\n\u00a0 \u00a0 int res = tlkos_msgq_send(sTlkTaskMsgQHandles[taskID],buffer, dataLen + 4,TLKOS_WAIT_FOREVER);\n\n\u00a0 \u00a0 if(res == TLK_ENONE){\n\n\u00a0 \u00a0 \u00a0 \u00a0 tlksys_task_wakeUp(taskID);\n\n\u00a0 \u00a0 }\n\n\u00a0 \u00a0 return res;\n\n}\n</code></pre>"},{"location":"Libraries/Telink/#tlkapp_enable_bt_stack","title":"tlkapp_enable_bt_stack","text":"<pre><code>void tlkapp_enable_bt_stack(void)\n\n{\n\n\u00a0 \u00a0 pm_set_dig_module_power_switch(FLD_PD_ZB_EN, PM_POWER_UP);\n\n\u00a0 \u00a0 user_init();\n\n\u00a0 \u00a0 delay_us(500);\n\n\u00a0 \u00a0 // PLL_264M_D25F_DSP_132M_HCLK_66M_PCLK_66M_MSPI_44M_WT_11M;\n\n\u00a0 \u00a0 app_btmgr_reStart();\n\n}\n</code></pre>"},{"location":"Libraries/Telink/#blc_svc_setdevicename","title":"blc_svc_setDeviceName","text":"<pre><code>void blc_svc_setDeviceName(const char *name);\n</code></pre>"},{"location":"Libraries/Telink/#smp-security","title":"smp security","text":"<pre><code>/**\n\n\u00a0* @brief \u00a0 \u00a0 \u00a0This function is used to set device's security parameters.\n\n\u00a0* @param[in] \u00a0mode - The bonding mode value can refer to the structure 'bonding_mode_t'.\n\n\u00a0* @param[in] \u00a0MITM_en - 0: Disable MITM protection; \u00a01: Enable MITM protection.\n\n\u00a0* @param[in] \u00a0method - 0: LE_Legacy_Pairing; 1: LE_Secure_Connection.\n\n\u00a0* @param[in] \u00a0OOB_en - 0: Disable OOB authentication; 1: Enable OOB authentication.\n\n\u00a0* @param[in] \u00a0keyPress_en - 0: Disable Keypress; 1: Enable Keypress.\n\n\u00a0* @param[in] \u00a0ioCapability - The IO capability's value can refer to the structure 'io_capability_t'.\n\n\u00a0* @return \u00a0 \u00a0 none.\n\n\u00a0*/\n\nvoid blc_smp_setSecurityParameters(bonding_mode_t mode, int MITM_en, pairing_methods_t method, int OOB_en, int keyPress_en, io_capability_t ioCapability);\n\nvoid blc_smp_setSecurityParameters_central(bonding_mode_t bond_mode, int MITM_en, pairing_methods_t method, int OOB_en, int keyPress_en, io_capability_t ioCapability);\n\nvoid blc_smp_setSecurityParameters_periphr(bonding_mode_t bond_mode, int MITM_en, pairing_methods_t method, int OOB_en, int keyPress_en, io_capability_t ioCapability);\n</code></pre>"},{"location":"Libraries/Telink/#register-server-app","title":"Register Server App","text":"<pre><code>void blc_prf_register_service_module(struct ble_prf_process *p_module, const void *param);\n</code></pre>"},{"location":"Libraries/Telink/#create-service","title":"Create Service","text":"<pre><code>extern void blc_gatts_addAttributeServiceGroup_old(atts_group_t *pGroup);\n#define blc_gatts_addAttributeServiceGroup(pGroup) \u00a0blc_gatts_addAttributeServiceGroup_old((atts_group_t *)pGroup)\n</code></pre>"},{"location":"Libraries/Telink/#attribute-values","title":"Attribute Values","text":"<p><pre><code>/**\n\n\u00a0* @brief \u00a0 \u00a0 \u00a0 Register ATT table.\n\n\u00a0* @param[in] \u00a0 p - Pointer point to attribute table.\n\n\u00a0* @return[in] \u00a00: success\n\n\u00a0* \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0other: fail\n\n\u00a0*/\n\nvoid bls_att_setAttributeTable(u8 *p);\n\ntypedef struct __attribute__((packed)) attribute\n{\n    u16                      attNum;\n    u8                       perm;\n    u8                       uuidLen;\n    u32                      attrLen; //4 bytes aligned\n    u8                      *uuid;\n    u8                      *pAttrValue;\n    att_readwrite_callback_t w;\n    att_readwrite_callback_t r;\n} attribute_t;\n</code></pre> There is\u00a0no\u00a0direct\u00a0equivalent\u00a0to\u00a0esp_ble_gatts_set_attr_value()\u00a0in the current Telink\u00a0SDK. To achieve the same functionality, you would need to:</p> <ol> <li> <p>Directly modify the attribute value pointer\u00a0(pAttrValue) in\u00a0your attribute table</p> </li> <li> <p>Implement\u00a0a custom function\u00a0similar to\u00a0what was referenced in your translation document</p> </li> <li> <p>Use the write callback mechanism\u00a0to handle dynamic value changes</p> </li> </ol> <p>The Telink SDK\u00a0uses a\u00a0more static, compile-time approach to attribute management compared to ESP32's dynamic runtime approach.</p>"},{"location":"Libraries/Telink/#gatt-start-service","title":"GATT Start Service","text":"<ol> <li> <p>Different Architecture:</p> </li> <li> <p>ESP32: Uses a dynamic service\u00a0creation model where\u00a0services\u00a0are created and then \"started\" to\u00a0make them available</p> </li> <li> <p>Telink: Uses a static attribute table approach where services are automatically available\u00a0once registered</p> </li> <li> <p>Service\u00a0Registration Process:</p> </li> <li> <p>ESP32:\u00a0esp_ble_gatts_create_service()\u00a0\u2192\u00a0esp_ble_gatts_start_service()</p> </li> <li> <p>Telink: Services are immediately available\u00a0when\u00a0registered via\u00a0bls_att_setAttributeTable()</p> </li> </ol>"},{"location":"Libraries/Telink/#add-characteristic","title":"Add Characteristic","text":"<p>The Telink SDK uses a static\u00a0attribute table that\u00a0defines all services and characteristics at compile\u00a0time. Here's\u00a0how it works:</p>"},{"location":"Libraries/Telink/#gatts-notify","title":"GATTS Notify","text":"<pre><code>/**\n\n\u00a0* \u00a0 @brief \u00a0Send a notification message to a client.\n\n\u00a0*\n\n\u00a0* \u00a0 @param[in] \u00a0 conn_handle \u00a0ACL Connection handle.\n\n\u00a0* \u00a0 @param[in] \u00a0 attr_handle \u00a0Attribute handle.\n\n\u00a0* \u00a0 @param[in] \u00a0 value \u00a0 \u00a0 \u00a0 \u00a0Pointer to the value to be notified.\n\n\u00a0* \u00a0 @param[in] \u00a0 len \u00a0 \u00a0 \u00a0 \u00a0 \u00a0Length of the value to be notified.\n\n\u00a0*\n\n\u00a0* \u00a0 @return BLE_HOST_ERR_SUCC if the handle value notification is sent successfully.\n\n\u00a0*/\n\nint ble_gatts_notify(uint16_t conn_handle, uint16_t attr_handle, const uint8_t *value, uint16_t len);\n\n/**\n *   @brief  Sends an ATT Handle Value Indication(ATT channel) PDU with the given parameters.\n *\n *   @param[in] conn_handle: The connection handle.\n *   @param[in] handle: The handle to indicate attribute value.\n *   @param[in] value: The attribute value to be indicated.\n *   @param[in] length: The size of the attribute value.\n *\n *   @return BLE_HOST_ERR_SUCC if the handle value indication is sent successfully.\n *      - BLE_L2CAP_ERR_ATT_INVALID_HANDLE if the handle is invalid.\n *      - BLE_L2CAP_ERR_INVALID_PARAMS if the value is NULL and length is not 0.\n */\nint ble_host_att_send_handle_value_indication(uint16_t conn_handle, uint16_t handle,\n    const uint8_t *value, uint16_t length);\n</code></pre>"}]}